<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入Flask配置</title>
    <link href="/2020/0710/46196.html"/>
    <url>/2020/0710/46196.html</url>
    
    <content type="html"><![CDATA[<h1 id="深入Flask配置"><a href="#深入Flask配置" class="headerlink" title="深入Flask配置"></a>深入Flask配置</h1><p>在Flask中，提供了丰富的全局配置来方便开发，以下是开发过程当中几个常用的配置选项。</p><table><thead><tr><th>配置名</th><th>作用</th></tr></thead><tbody><tr><td>DEBUG</td><td>启用/禁用调试模式</td></tr><tr><td>SECRET_KEY</td><td>密钥</td></tr><tr><td>SERVER_NAME</td><td>服务器名和端口。需要这个选项来支持子域名 （例如： <code>&#39;myapp.dev:5000&#39;</code> ）。注意 localhost 不支持子域名，所以把这个选项设置为 “localhost” 没有意义。设置 <code>SERVER_NAME</code> 默认会允许在没有请求上下文而仅有应用上下文时生成 URL</td></tr><tr><td>SESSION_COOKIE_NAME</td><td>会话 cookie 的名称。</td></tr></tbody></table><p>更多的配置详见<a href="http://docs.jinkan.org/docs/flask/config.html" target="_blank" rel="noopener">官方文档</a>。</p><p>如果要在 <code>Flask</code> 中激活某些的配置，通常有以下8种方式，前面的两种都是针对某个单独配置。第三种方式，就是采用字典的更新键值对的方法，因为 <code>Config</code> 类本身就是继承自字典，所以同时也继承了字典的 <code>update</code> 方法。 而后面的几种方式，则可以对多个配置项进行处理。</p><div class="hljs"><pre><code class="hljs python">app.debug  = <span class="hljs-literal">True</span>app.config[<span class="hljs-string">"debug"</span>] = <span class="hljs-literal">True</span>app.config.update()app.config.from_envvar()app.config.from_json()app.config.from_mapping()app.config.from_pyfile()app.config.from_object()</code></pre></div><p>下面谈谈其他几种方法的内部操作以及原理。</p><h2 id="一、Config-配置类的创建过程"><a href="#一、Config-配置类的创建过程" class="headerlink" title="一、Config 配置类的创建过程"></a>一、<code>Config</code> 配置类的创建过程</h2><p>首先 <code>Config</code> 类是在 <code>flask/config.py</code> 文件里面。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># 从这里可以看出 Config类 继承了 dict</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span><span class="hljs-params">(dict)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, root_path, defaults=None)</span>:</span>        dict.__init__(self, defaults <span class="hljs-keyword">or</span> &#123;&#125;)        self.root_path = root_path</code></pre></div><p>下面是 <code>flask/app.py</code> 里面的 <code>Flask</code> 类，由于这个类的代码数量庞大，所以只贴出一点用到了 <code>Config</code> 类的地方。</p><p>可以看到 <code>default_config</code>  是一个 <code>ImmutableDict</code> <strong>（不可变字典对象）</strong>，里面是所有支持的配置项，并且都给出了默认值。</p><p>而 <code>Config</code> 类会被赋值给 <code>Flask</code> 的成员对象 <code>config_class</code>，但此时这个成员对象，也就是字典对象，还没有任何数据；所以要通过 <code>Flask</code> 的 <code>make_config</code> 来为 <code>config_class</code> 赋值字典数据，而此时传入的配置就是 <code>defaults</code>，包包含了  <code>Flask</code> 全部配置项。  初始时的两个配置项 <code>ENV</code> 和 <code>DEBUG</code> 会通过 <code>get_env()</code> 方法 和 <code>get_debug()</code> 方法设置为 <code>production</code> 和 <code>False</code>。 </p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flask</span><span class="hljs-params">(_PackageBoundObject)</span>:</span>    <span class="hljs-comment"># 这里的 Config 类就是 flask/Config.py 下面的 Config 类</span>    config_class = Config        <span class="hljs-comment"># 所有支持的配置项</span>    default_config = ImmutableDict(        &#123;            <span class="hljs-string">"ENV"</span>: <span class="hljs-literal">None</span>,            <span class="hljs-string">"DEBUG"</span>: <span class="hljs-literal">None</span>,            <span class="hljs-string">"TESTING"</span>: <span class="hljs-literal">False</span>,            <span class="hljs-string">"PROPAGATE_EXCEPTIONS"</span>: <span class="hljs-literal">None</span>,            <span class="hljs-string">"PRESERVE_CONTEXT_ON_EXCEPTION"</span>: <span class="hljs-literal">None</span>,            <span class="hljs-string">"SECRET_KEY"</span>: <span class="hljs-literal">None</span>,            <span class="hljs-string">"PERMANENT_SESSION_LIFETIME"</span>: timedelta(days=<span class="hljs-number">31</span>),            <span class="hljs-string">"USE_X_SENDFILE"</span>: <span class="hljs-literal">False</span>,            <span class="hljs-string">"SERVER_NAME"</span>: <span class="hljs-literal">None</span>,            <span class="hljs-string">"APPLICATION_ROOT"</span>: <span class="hljs-string">"/"</span>,            <span class="hljs-string">"SESSION_COOKIE_NAME"</span>: <span class="hljs-string">"session"</span>,            <span class="hljs-string">"SESSION_COOKIE_DOMAIN"</span>: <span class="hljs-literal">None</span>,            <span class="hljs-string">"SESSION_COOKIE_PATH"</span>: <span class="hljs-literal">None</span>,            <span class="hljs-string">"SESSION_COOKIE_HTTPONLY"</span>: <span class="hljs-literal">True</span>,            <span class="hljs-string">"SESSION_COOKIE_SECURE"</span>: <span class="hljs-literal">False</span>,            <span class="hljs-string">"SESSION_COOKIE_SAMESITE"</span>: <span class="hljs-literal">None</span>,            <span class="hljs-string">"SESSION_REFRESH_EACH_REQUEST"</span>: <span class="hljs-literal">True</span>,            <span class="hljs-string">"MAX_CONTENT_LENGTH"</span>: <span class="hljs-literal">None</span>,            <span class="hljs-string">"SEND_FILE_MAX_AGE_DEFAULT"</span>: timedelta(hours=<span class="hljs-number">12</span>),            <span class="hljs-string">"TRAP_BAD_REQUEST_ERRORS"</span>: <span class="hljs-literal">None</span>,            <span class="hljs-string">"TRAP_HTTP_EXCEPTIONS"</span>: <span class="hljs-literal">False</span>,            <span class="hljs-string">"EXPLAIN_TEMPLATE_LOADING"</span>: <span class="hljs-literal">False</span>,            <span class="hljs-string">"PREFERRED_URL_SCHEME"</span>: <span class="hljs-string">"http"</span>,            <span class="hljs-string">"JSON_AS_ASCII"</span>: <span class="hljs-literal">True</span>,            <span class="hljs-string">"JSON_SORT_KEYS"</span>: <span class="hljs-literal">True</span>,            <span class="hljs-string">"JSONIFY_PRETTYPRINT_REGULAR"</span>: <span class="hljs-literal">False</span>,            <span class="hljs-string">"JSONIFY_MIMETYPE"</span>: <span class="hljs-string">"application/json"</span>,            <span class="hljs-string">"TEMPLATES_AUTO_RELOAD"</span>: <span class="hljs-literal">None</span>,            <span class="hljs-string">"MAX_COOKIE_SIZE"</span>: <span class="hljs-number">4093</span>,        &#125;    )        <span class="hljs-comment"># 返回初始完毕的配置类</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_config</span><span class="hljs-params">(self, instance_relative=False)</span>:</span>        root_path = self.root_path        <span class="hljs-keyword">if</span> instance_relative:            root_path = self.instance_path        defaults = dict(self.default_config)        defaults[<span class="hljs-string">"ENV"</span>] = get_env()        defaults[<span class="hljs-string">"DEBUG"</span>] = get_debug_flag()        <span class="hljs-keyword">return</span> self.config_class(root_path, defaults)</code></pre></div><h2 id="二、从环境变量中读取配置属性"><a href="#二、从环境变量中读取配置属性" class="headerlink" title="二、从环境变量中读取配置属性"></a>二、从环境变量中读取配置属性</h2><p>当在环境变量中设置了配置文件的环境变量，那么则可以使用这个方法。</p><p>首先是使用 <code>os</code> 模块的 <code>environ.get()</code> 方法来获取环境变量属性值，而后再调用另一个方法，这个环境变量的属性值是一个文件路径，通常的话，这个配置文件应该方法在和启动文件在同一个路径下。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_envvar</span><span class="hljs-params">(self, variable_name, silent=False)</span>:</span>        rv = os.environ.get(variable_name)        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> rv:            <span class="hljs-keyword">if</span> silent:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">raise</span> RuntimeError(                <span class="hljs-string">"The environment variable %r is not set "</span>                <span class="hljs-string">"and as such configuration could not be "</span>                <span class="hljs-string">"loaded.  Set this variable and make it "</span>                <span class="hljs-string">"point to a configuration file"</span> % variable_name            )        <span class="hljs-keyword">return</span> self.from_pyfile(rv, silent=silent)</code></pre></div><p>在项目的同目录下创建一个 <code>config.cfg</code> 配置文件，写入两个简单的配置项。</p><div class="hljs"><pre><code class="hljs shell">DEBUG=TrueSECRET_KEY="something"</code></pre></div><p>使用os模块临时设置一个环境变量，当从环境变量中读取到配置文件后，在网页中能打印到配置属性的值。</p><p>还有一种办法是(针对 <code>Linux</code> 环境)，新开一个终端，切换到项目的目录下，在启动项目前，先使用 <code>export FLASK_CONFIG=config.cfg</code>，然后启动文件里面只需要写 <code>app.config.from_envvar(&quot;FLASK_CONFIG&quot;)</code>就可以，当然使用 <code>export</code> 设置的也只是一个临时变量，只对目前的终端有效。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flaskapp = Flask(__name__)os.environ.setdefault(<span class="hljs-string">"FLASK_CONFIG"</span>, <span class="hljs-string">"config.cfg"</span>)app.config.from_envvar(<span class="hljs-string">"FLASK_CONFIG"</span>)<span class="hljs-meta">@app.route("/")</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">"DEBUG %s SECRET_KEY %s"</span> % (app.config.get(<span class="hljs-string">"DEBUG"</span>), app.config.get(<span class="hljs-string">"SECRET_KEY"</span>))<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    app.run()</code></pre></div><p>我比较在意的是这个 <code>silent</code> 参数， 这个参数的含义是，当配置文件丢失时，或者环境变量没有设置时，设置 <code>silent</code> 参数为True，那么就等于没有配置这个文件。</p><p>那么可以写一个函数来检测这个配置文件是否存在，是否设置环境变量，当两个都没有时，返回 <code>True</code>，然后 <code>from_envvar</code> 方法将会不起作用，触发异常。</p><p>下面是一个简单的例子。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<span class="hljs-keyword">import</span> osapp = Flask(__name__)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_set</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.environ.get(<span class="hljs-string">"FLASK_CONFIG"</span>):        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> os.path.exists(<span class="hljs-string">"config.cfg"</span>):        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>app.config.from_envvar(<span class="hljs-string">"FLASK_CONFIG"</span>, silent=is_set())<span class="hljs-meta">@app.route("/")</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span></span><span class="hljs-function">    <span class="hljs-title">return</span> "<span class="hljs-title">DEBUG</span> %<span class="hljs-title">s</span> <span class="hljs-title">SECRET_KEY</span> %<span class="hljs-title">s</span>" % <span class="hljs-params">(app.config.get<span class="hljs-params">(<span class="hljs-string">"DEBUG"</span>)</span>, app.config.get<span class="hljs-params">(<span class="hljs-string">"SECRET_KEY"</span>)</span>)</span></span><span class="hljs-function"></span>if __name__ == "__main__":    app.run()</code></pre></div><p>针对 <code>silent</code> 参数，写出一个方法来最终决定 <code>silent</code> 的值，这样防止了中间环境变量配置出错以及文件不存在等等情况。</p><h2 id="三、-从-python-文件中读取配置属性"><a href="#三、-从-python-文件中读取配置属性" class="headerlink" title="三、 从 python 文件中读取配置属性"></a>三、 从 <code>python</code> 文件中读取配置属性</h2><blockquote><p>  当创建一个 <code>Flask</code> 的实例对象之后，使用 <code>app.config.from_pyfile</code> 方法，传入一个配置文件字符串，从配置文件中读取属性并且写入，前面的 <code>from_envvar</code> 方法获取到配置文件后最终也会调用这个方法，并且，这个方法最终也会调用下一个方法 <code>from_object</code>。</p></blockquote><div class="hljs"><pre><code class="hljs C"><span class="hljs-function">def <span class="hljs-title">from_pyfile</span><span class="hljs-params">(self, filename, silent=False)</span>:</span><span class="hljs-function">    filename </span>= os.path.join(self.root_path, filename)        d = types.ModuleType(<span class="hljs-string">"config"</span>)        d.__file__ = filename    <span class="hljs-keyword">try</span>:with <span class="hljs-built_in">open</span>(filename, mode=<span class="hljs-string">"rb"</span>) as config_file:exec(compile(config_file.<span class="hljs-built_in">read</span>(), filename, <span class="hljs-string">"exec"</span>), d.__dict__)    except IOError as e:<span class="hljs-keyword">if</span> silent <span class="hljs-keyword">and</span> e.errno in (errno.ENOENT, errno.EISDIR, errno.ENOTDIR):<span class="hljs-keyword">return</span> False    e.strerror = <span class="hljs-string">"Unable to load configuration file (%s)"</span> % e.strerror    raise    self.from_object(d)    <span class="hljs-keyword">return</span> True</code></pre></div><p>在项目的根目录下创建一个名为 <code>config.cfg</code> 简单配置文件。</p><div class="hljs"><pre><code class="hljs python">DEBUG=<span class="hljs-literal">True</span>SECRET_KEY=<span class="hljs-string">"something"</span></code></pre></div><p>先看 <code>from_pyfile</code> 文件前面的三段代码， 首先使用 <code>os</code>获取配置文件的绝对路径，然后用 <code>types.ModuleType</code> 方法动态创建了一个 <code>config</code> 模块，并且设置文件名为传进来的文件名的绝对路径文件名，此时这个 <code>config</code> 算是一个模块了，不是用普通的 <code>import</code> 方法导入的。</p><div class="hljs"><pre><code class="hljs python">filename = os.path.join(self.root_path, filename)d = types.ModuleType(<span class="hljs-string">"config"</span>)d.__file__ = filename</code></pre></div><p><code>types</code> 属于 <code>Python</code>的标准库，里面的几个常用的方法没怎么了解，有如下几个。</p><ul><li><code>FunctionType</code>：通过不使用 <code>def</code> 的方式动态创建一个函数。</li><li><code>MethodType</code>：将创建在类外的某个方法动态绑定到类的实例上。</li><li><code>ModuleType</code>：动态的创建一个临时的模块。</li></ul><div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> types<span class="hljs-comment"># 动态创建一个模块</span><span class="hljs-meta">&gt;&gt;&gt; </span>m = types.ModuleType(<span class="hljs-string">"sample"</span>, <span class="hljs-string">"sample module."</span>)  <span class="hljs-comment"># 传入一个模块名，以及模块的文档字符串</span><span class="hljs-meta">&gt;&gt;&gt; </span>m&lt;module <span class="hljs-string">'sample'</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>m.__dict__&#123;<span class="hljs-string">'__name__'</span>: <span class="hljs-string">'sample'</span>, <span class="hljs-string">'__doc__'</span>: <span class="hljs-string">'sample module.'</span>, <span class="hljs-string">'__package__'</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">'__loader__'</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">'__spec__'</span>: <span class="hljs-literal">None</span>&#125;<span class="hljs-meta">&gt;&gt;&gt; </span>m <span class="hljs-keyword">in</span> sys.modules   <span class="hljs-comment"># 模块不包含在系统模块中</span><span class="hljs-literal">False</span><span class="hljs-comment"># 动态添加类方法</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><span class="hljs-meta">... </span>    <span class="hljs-keyword">pass</span><span class="hljs-meta">... </span><span class="hljs-meta">&gt;&gt;&gt; </span>p = Person()<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say</span><span class="hljs-params">(self)</span>:</span> print(<span class="hljs-string">"hello"</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>p.say = types.MethodType(say, p)<span class="hljs-meta">&gt;&gt;&gt; </span>p.say()hello<span class="hljs-comment"># 动态创建一个函数</span>&gt;&gt; foo_code = compile(<span class="hljs-string">'def foo(): return "bar"'</span>, <span class="hljs-string">"&lt;string&gt;"</span>, <span class="hljs-string">"exec"</span>)&gt;&gt; foo_func = types.FunctionType(foo_code.co_consts[<span class="hljs-number">0</span>], globals(), <span class="hljs-string">"foo"</span>)&gt;&gt; print(foo_func())bar</code></pre></div><p>继续看 <code>from_pyfile</code> 方法剩下的代码，读取配置文件的配置属性，此时把属性放进动态创建的模块的字典里头，最后是调用另一个方法。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    <span class="hljs-keyword">with</span> open(filename, mode=<span class="hljs-string">"rb"</span>) <span class="hljs-keyword">as</span> config_file:exec(compile(config_file.read(), filename, <span class="hljs-string">"exec"</span>), d.__dict__)<span class="hljs-keyword">except</span> IOError <span class="hljs-keyword">as</span> e:<span class="hljs-keyword">if</span> silent <span class="hljs-keyword">and</span> e.errno <span class="hljs-keyword">in</span> (errno.ENOENT, errno.EISDIR, errno.ENOTDIR):<span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    e.strerror = <span class="hljs-string">"Unable to load configuration file (%s)"</span> % e.strerror<span class="hljs-keyword">raise</span>self.from_object(d)<span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h2 id="四、从-python对象中提取属性"><a href="#四、从-python对象中提取属性" class="headerlink" title="四、从  python对象中提取属性"></a>四、从  <code>python</code>对象中提取属性</h2><p>从 <code>python</code> 对象中提取配置相对简单，一般写一个配置类的 <code>python</code> 文件，里面定义一个基类，设定一些基本配置，然后使用类继承的方法为各种环境设置扩展配置类，一个简单的配置类如下。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span><span class="hljs-params">(object)</span>:</span>    DEBUG = <span class="hljs-literal">False</span>    TESTING = <span class="hljs-literal">False</span>    DATABASE_URI = <span class="hljs-string">'sqlite://:memory:'</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductionConfig</span><span class="hljs-params">(Config)</span>:</span>    DATABASE_URI = <span class="hljs-string">'mysql://user@localhost/foo'</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DevelopmentConfig</span><span class="hljs-params">(Config)</span>:</span>    DEBUG = <span class="hljs-literal">True</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestingConfig</span><span class="hljs-params">(Config)</span>:</span>    TESTING = <span class="hljs-literal">True</span></code></pre></div><p>之后就是在 <code>from_object</code> 方法里传入一个类名，或者一个完整的模块字符串就可以配置好配置属性。如果传入的是一个配置类，那么 <code>if isinstance(obj, string_types)</code> 直接为 <code>False</code>，然后这个传入的配置类的所有属性，如果包含大写的属性，将存入 <code>app.config</code> 的字典中。如果是字符串，那么会先把模块里面的类导入再提取属性。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_object</span><span class="hljs-params">(self, obj)</span>:</span>   <span class="hljs-keyword">if</span> isinstance(obj, string_types):            obj = import_string(obj)    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> dir(obj):        <span class="hljs-keyword">if</span> key.isupper():            self[key] = getattr(obj, key)</code></pre></div><p><code>string_types</code> ，这个变量在  <code>flask</code> 包的  <code>_compat.py</code>  下，其实就是<code>string</code> 类型，所以简单对传进来的参数检查是不是个字符串，如果是字符串，则会调用 <code>import_string</code> 方法，如果不是字符串而是一个具体的类则直接执行 <code>for</code> 循环对类的属性遍历。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:  <span class="hljs-comment"># Python 2</span>    text_type = unicode    string_types = (str, unicode)    integer_types = (int, long)<span class="hljs-keyword">except</span> NameError:  <span class="hljs-comment"># Python 3</span>    text_type = str    string_types = (str,)    integer_types = (int,)</code></pre></div><p>然后是  <code>import_string</code> 方法，因为传进来的仅仅是个字符串，还没对模块进行导入，所以会用到 <code>werkzeug.utils</code> 包下的 <code>import_string</code> 方法对模块进行导入。</p><p>可以看到 <code>import_string</code>  的第一行代码会对字符串进行替换，那说明有两种写法，而恰恰函数文档也说明了。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-string">"""</span><span class="hljs-string">提供两种模块写法：例如</span><span class="hljs-string">xml.sax.saxutils.escape</span><span class="hljs-string">xml.sax.saxutils:escape</span><span class="hljs-string">无论是那种写法，最后都会变成下面这种写法</span><span class="hljs-string">xml.sax.saxutils.escape</span><span class="hljs-string">"""</span>import_name = str(import_name).replace(<span class="hljs-string">":"</span>, <span class="hljs-string">"."</span>)</code></pre></div><p>接下来就是使用不寻常的导包方式，一般导包都是两种方式，<code>import package</code>或者是 <code>from package import module</code>，因为我们这里传进来的是字符串，所以不能用正常的导包方式，只能使用 <code>__import__</code> 这个内建方法，实际上 <code>import</code> 也是调用 <code>__import__</code>。假设配置类 <code>BaseConfig</code> 在 <code>Config</code>  包下的 <code>Settings.py</code> 模块下，那么可以写为 <code>Config.Settings:BaseConfig</code>，或者 <code>Config.Settings.BaseConfig</code> ，两者的可以。最终，如果导入为空时，那么会从 <code>sys.modules</code> 里面查询这个包。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    __import__(import_name)<span class="hljs-keyword">except</span> ImportError:    <span class="hljs-keyword">if</span> <span class="hljs-string">"."</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> import_name:        <span class="hljs-keyword">raise</span><span class="hljs-keyword">else</span>:    <span class="hljs-keyword">return</span> sys.modules[import_name]</code></pre></div><p>如果这个传入的配置类字符串为 <code>Config.Settings.BaseConfig</code>，那么先把模块名和对象名分开，再尝试使用 <code>__import__</code> 方法导入，此时已经把模块名和对象名分开了，分别把模块名和对象名传入 <code>__import__</code> 就可以正常导入。再使用 <code>getattr</code> 方法获取模块里面的对象，这个方法告一段落。最后就是把返回的对象遍历获取里面的配置属性添加到 <code>Config</code> 对象中。</p><p><code>__import_</code> 的四个参数：</p><ul><li><code>name (required)</code>: 被加载 <code>module</code> 的名称</li><li><code>globals (optional)</code> : 包含全局变量的字典，该选项很少使用，采用默认值 <code>global()</code></li><li><code>locals (optional)</code>:  包含局部变量的字典，内部标准实现未用到该变量，采用默认值 <code>local()</code></li><li><code>fromlist (Optional)</code> : 被导入的子模块名称</li></ul><div class="hljs"><pre><code class="hljs python">module_name, obj_name = import_name.rsplit(<span class="hljs-string">"."</span>, <span class="hljs-number">1</span>)module = __import__(module_name, globals(), locals(), [obj_name])<span class="hljs-keyword">try</span>:    <span class="hljs-keyword">return</span> getattr(module, obj_name)<span class="hljs-keyword">except</span> AttributeError <span class="hljs-keyword">as</span> e:    <span class="hljs-keyword">raise</span> ImportError(e)</code></pre></div><p>总的来说这个方法提供了两种导入配置的选择，一种是传入模块字符串，一种是直接传入配置类。便于导入的时候选择导入方式和可扩展性。</p><h2 id="五、从-json-文件中读取配置属性到映射为字典"><a href="#五、从-json-文件中读取配置属性到映射为字典" class="headerlink" title="五、从 json 文件中读取配置属性到映射为字典"></a>五、从 <code>json</code> 文件中读取配置属性到映射为字典</h2><p>这个方法最终也会调用 <code>Config</code> 类的最后一个方法，对于这个方法而言，只是简单的读取一下 <code>json</code> 文件，并且把 <code>json</code> 文件里面的数据转化为 <code>Python</code> 当中的字典类型。同时可以设置 <code>silent</code> 为 <code>True</code>，当文件读取失败的时候，方法直接失效，如果不设置为 <code>True</code> 的话，也可以，直接触发标准错误。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_json</span><span class="hljs-params">(self, filename, silent=False)</span>:</span>    filename = os.path.join(self.root_path, filename)    <span class="hljs-keyword">try</span>:        <span class="hljs-keyword">with</span> open(filename) <span class="hljs-keyword">as</span> json_file:            obj = json.loads(json_file.read())<span class="hljs-keyword">except</span> IOError <span class="hljs-keyword">as</span> e:<span class="hljs-keyword">if</span> silent <span class="hljs-keyword">and</span> e.errno <span class="hljs-keyword">in</span> (errno.ENOENT, errno.EISDIR):<span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>e.strerror = <span class="hljs-string">"Unable to load configuration file (%s)"</span> % e.strerror<span class="hljs-keyword">raise</span><span class="hljs-keyword">return</span> self.from_mapping(obj)</code></pre></div><p>在项目的根目录下创建一个名为 <code>config.json</code> 的配置文件。</p><div class="hljs"><pre><code class="hljs C">&#123;    <span class="hljs-string">"DEBUG"</span>: <span class="hljs-string">"True"</span>,    <span class="hljs-string">"SECRET_KEY"</span>: <span class="hljs-string">"something"</span>&#125;</code></pre></div><p>示例代码，当程序启动时，打开 <code>http://127.0.0.1:5000/</code> 就可以看到 <code>DEBUG</code> 和 <code>SECRET_KEY</code> 的值。</p><div class="hljs"><pre><code class="hljs C">from flask <span class="hljs-keyword">import</span> Flaskapp = Flask(__name__)app.<span class="hljs-built_in">config</span>.from_json(<span class="hljs-string">"config.json"</span>)@app.route(<span class="hljs-string">"/"</span>)def index():    <span class="hljs-keyword">return</span> <span class="hljs-string">"DEBUG %s SECRET_KEY %s"</span> % (app.<span class="hljs-built_in">config</span>.<span class="hljs-built_in">get</span>(<span class="hljs-string">"DEBUG"</span>), app.<span class="hljs-built_in">config</span>.<span class="hljs-built_in">get</span>(<span class="hljs-string">"SECRET_KEY"</span>))<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    app.<span class="hljs-built_in">run</span>()    <span class="hljs-built_in">print</span>(app.<span class="hljs-built_in">config</span>.items())</code></pre></div><h2 id="六、从-python-键值对-dict-中配置属性"><a href="#六、从-python-键值对-dict-中配置属性" class="headerlink" title="六、从 python 键值对 ( dict ) 中配置属性"></a>六、从 <code>python</code> 键值对 <code>( dict )</code> 中配置属性</h2><p>设置一个简单的字典对象，待会传入 <code>from_mappings</code> 方法。</p><div class="hljs"><pre><code class="hljs python">configs = &#123;    <span class="hljs-string">"DEBUG"</span>: <span class="hljs-literal">True</span>,    <span class="hljs-string">"SECRET_KEY"</span>: <span class="hljs-string">"Something"</span>&#125;</code></pre></div><p>最后一个方法，针对传进来的键值对，也就是字典，这里对应第三个参数 <code>**kwargs</code>，使用 <code>kwargs.items()</code> 提取出所有的键值对( 列表格式 ) 存放进 <code>mappings</code> 列表里，然后再通过二层循环提取出每个配置的键和值，存放进 <code>Config</code> 类的里面。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_mapping</span><span class="hljs-params">(self, *mapping, **kwargs)</span>:</span>            mappings = []        <span class="hljs-keyword">if</span> len(mapping) == <span class="hljs-number">1</span>:            <span class="hljs-keyword">if</span> hasattr(mapping[<span class="hljs-number">0</span>], <span class="hljs-string">"items"</span>):                mappings.append(mapping[<span class="hljs-number">0</span>].items())            <span class="hljs-keyword">else</span>:                mappings.append(mapping[<span class="hljs-number">0</span>])        <span class="hljs-keyword">elif</span> len(mapping) &gt; <span class="hljs-number">1</span>:            <span class="hljs-keyword">raise</span> TypeError(                <span class="hljs-string">"expected at most 1 positional argument, got %d"</span> % len(mapping)            )        mappings.append(kwargs.items())        <span class="hljs-keyword">for</span> mapping <span class="hljs-keyword">in</span> mappings:            <span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> mapping:                <span class="hljs-keyword">if</span> key.isupper():                    self[key] = value        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><p>例子示范，当启动程序时，在浏览器进入 <code>http://127.0.0.1:5000/</code> 就能看到 <code>DEBUG</code> 和 <code>SECRET_KEY</code> 的值。</p><div class="hljs"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flaskapp = Flask(__name__)configs = &#123;    <span class="hljs-string">"DEBUG"</span>: <span class="hljs-literal">True</span>,    <span class="hljs-string">"SECRET_KEY"</span>: <span class="hljs-string">"Something"</span>&#125;app.config.from_mappings(configs)<span class="hljs-meta">@app.route("/")</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">"DEBUG %s SECRET_KEY %s"</span> % (app.config.get(<span class="hljs-string">"DEBUG"</span>), app.config.get(<span class="hljs-string">"SECRET_KEY"</span>))<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    app.run()    print(app.config.items())</code></pre></div><p>然后这个方法还提供另一种细化的使用，上面只是传入了第三个参数，第二个参数还没使用，显然这个函数是会使用到第二参数，那么这个参数格式有几种写法：</p><div class="hljs"><pre><code class="hljs python">mapping = (    &#123;        <span class="hljs-string">"DEBUG"</span>: <span class="hljs-literal">True</span>,        <span class="hljs-string">"SECRET_KEY"</span>: <span class="hljs-string">"Something"</span>    &#125;)<span class="hljs-comment"># 直接执行 mappings.append(mapping[0])</span>mapping = (    (<span class="hljs-string">'DEBUG'</span>, <span class="hljs-literal">True</span>),    (<span class="hljs-string">'TESTING'</span>, <span class="hljs-literal">False</span>))<span class="hljs-comment"># 传入元祖，直接执行 mappings.append(mapping[0])</span></code></pre></div><p>此时就不需要传入第三个参数，也就是说这个方法提供两种参数传入方式，也方便扩展，如果单纯使用键值对，那么前面的代码将不会被执行，如果使用 <code>tuple</code> ，也会对这个参数进行操作，提取里面的属性值。</p><h2 id="七、自定义读取-yaml-properties配置文件"><a href="#七、自定义读取-yaml-properties配置文件" class="headerlink" title="七、自定义读取 yaml/properties配置文件"></a>七、自定义读取 yaml/properties配置文件</h2><blockquote><p>  上面提到可以用 <code>types.MethodType</code> 来创建动态方法，这里就可以利用这个来为 <code>config</code> 扩展读取更多类型的配置文件。</p></blockquote><p>示例如下：</p><div class="hljs"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> types<span class="hljs-comment"># 创建一个 Person 类，此时类里还没有任何方法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>    <span class="hljs-keyword">pass</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say</span><span class="hljs-params">(self, name)</span>:</span>    self.name = name    print(<span class="hljs-string">"hello"</span>, name)    p = Person()<span class="hljs-comment"># 强行把方法赋值到实例对象上</span>p.say = sayp.say(name=<span class="hljs-string">"nick"</span>) <span class="hljs-comment"># 报错</span><span class="hljs-comment"># say() missing 1 required positional argument: 'self'</span><span class="hljs-comment"># 把 say 方法绑定到 Person 类的实例上</span>p.say = types.MethodType(say, p)p.say(name=<span class="hljs-string">"nick"</span>)<span class="hljs-comment"># result: hello nick</span></code></pre></div><p>创建一个名为 <code>config.yaml</code> 的配置文件，写入两个简单的配置项。</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">DEBUG:</span> <span class="hljs-literal">True</span><span class="hljs-attr">SECRET_KEY:</span> <span class="hljs-string">something</span></code></pre></div><p>读取 <code>yaml</code> 文件，编写读取 <code>yaml</code> 文件方法，利用了 <code>pyyaml</code> 库，使用  <code>yaml</code> 读取出来的数据是字典格式，然后传递给  <code>Config</code> 对象的        <code>from_mapping</code> 方法，然后利用 <code>types.MethodType</code> 方法为 <code>Config</code> 类动态添加方法，绑定在 <code>config</code> 对象上。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<span class="hljs-keyword">import</span> types<span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> yamlapp = Flask(__name__)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_yaml</span><span class="hljs-params">(self, filename, silent=False)</span>:</span>    filename = os.path.join(self.root_path, filename)    <span class="hljs-keyword">try</span>:        <span class="hljs-keyword">with</span> open(filename) <span class="hljs-keyword">as</span> yaml_file:            obj = yaml.load(yaml_file.read(), Loader=yaml.FullLoader)    <span class="hljs-keyword">except</span> IOError <span class="hljs-keyword">as</span> e:        <span class="hljs-keyword">if</span> silent:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    <span class="hljs-keyword">return</span> self.from_mapping(obj)<span class="hljs-comment"># MethodType 方法第一个参数是需要动态添加的方法名，第二个参数是类的实例对象。</span>app.config.from_yaml = types.MethodType(from_yaml, app.config)app.config.from_yaml(<span class="hljs-string">"config.yaml"</span>)<span class="hljs-meta">@app.route("/")</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">"DEBUG %s SECRET_KEY %s"</span> % (app.config.get(<span class="hljs-string">"DEBUG"</span>), app.config.get(<span class="hljs-string">"SECRET_KEY"</span>))<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    app.run()    print(app.config.items())</code></pre></div><p>创建一个名为 <code>config.properties</code> 的简单配置文件，写入以下简单配置项。</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-attr">DEBUG</span>=<span class="hljs-string">True</span><span class="hljs-attr">SECRET_KEY</span>=<span class="hljs-string">something</span></code></pre></div><p>创建一个读取 <code>from_properties</code> 方法， 这个方法遍历  <code>properties</code> 文件的每一行，把  <code>=</code>  两边的属性名和属性值放进 <code>obj</code> 中，最终会调用现有的 <code>from_mapping</code> 方法，最后还是要利用 <code>types.MethodType</code> 方法为 <code>Config</code> 类动态添加方法，绑定在 <code>config</code> 对象上，这样这个方法才会起作用。</p><div class="hljs"><pre><code class="hljs python">app = Flask(__name__)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_properties</span><span class="hljs-params">(self, filename, silent=False, encode=None)</span>:</span>    filename = os.path.join(self.root_path, filename)    <span class="hljs-keyword">try</span>:        <span class="hljs-keyword">with</span> open(filename) <span class="hljs-keyword">as</span> properties_file:            obj = &#123;&#125;            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> properties_file:                <span class="hljs-keyword">if</span> line.find(<span class="hljs-string">'='</span>) &gt; <span class="hljs-number">0</span>:                    s = line.replace(<span class="hljs-string">'\n'</span>, <span class="hljs-string">''</span>).split(<span class="hljs-string">"="</span>)                    obj[s[<span class="hljs-number">0</span>]] = s[<span class="hljs-number">1</span>]    <span class="hljs-keyword">except</span> IOError <span class="hljs-keyword">as</span> e:        <span class="hljs-keyword">if</span> silent:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    <span class="hljs-keyword">return</span> self.from_mapping(obj)app.config.from_properties = types.MethodType(from_properties, app.config)app.config.from_properties(<span class="hljs-string">"config.properties"</span>)</code></pre></div><p>当然，这两个方法可能也有不完善的地方，例如，<code>yaml</code> 文件可能是多层级的，这里只考虑到一层级，什么时候下才会出现多层级的配置项，例如，可以在一个 <code>yaml</code> 文件里面设置多个环境配置，开发环境配置，生产环境配置，部署环境配置等。</p><ul><li><input disabled="" type="checkbox"> <code>yaml</code> 方法修改。</li><li><input disabled="" type="checkbox"> 实例代码上传至 <code>github</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux与Android剪切板同步方案</title>
    <link href="/2020/0516/12368.html"/>
    <url>/2020/0516/12368.html</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-与-Android-剪切板同步方案"><a href="#Linux-与-Android-剪切板同步方案" class="headerlink" title="Linux 与 Android 剪切板同步方案"></a><code>Linux</code> 与 <code>Android</code> 剪切板同步方案</h1><p>在 <code>Linux</code> 传输文件，图片，或是发送文字，都不如 <code>Windows</code> 那样方便，在 <code>Windows</code>  可以通过 <code>QQ</code> 里面发送文件，图片，或是文字等等。虽然说在<code>Linux</code>上可以通过其他方式来解决传文件的文件，例如：</p><a id="more"></a><ul><li><p><code>telegram</code></p></li><li><p>微信网页版( 在2017年9月份开始，腾讯已经 开始限制 新注册的微信号禁止登录网页版微信，老的微信号则不受影响 ，并且网页版发送的文件大小不能超过 <code>90MB</code></p></li><li><p><code>python -m http.server 80</code>，但是不能复制文本，而且有些文件需要另存为下载。</p></li><li><p>以及其他方法。。。</p></li></ul><p>现在找到 一种办法，电脑上使用 <code>GSConnect</code>，而安卓软件选择使用 <code>KDE Connect</code>。</p><p><code>GSConnect</code> 官方介绍：</p><blockquote><p>  <code>GSConnect</code> 是针对 <code>GNOME Shell</code> 的 <code>KDE Connect</code> 的完整实现，集成了 <code>Nautilus</code> 、<code>Chrome</code> 和 <code>Firefox</code>。</p><p>  将你的 PC 和 Android 设备与安装的 KDE Connect 应用配对: 传输文件，发送和接收短信文本，同步剪贴板和通知，发送鼠标和键盘输入，远程控制媒体播放器，定位你的设备，监视电池电量，在你的 PC 上启动命令，等等。</p></blockquote><p><code>GSConnect</code> 官方 <code>WIKI</code>：<a href="https://github.com/andyholmes/gnome-shell-extension-gsconnect/wiki/Installation#install-from-git" target="_blank" rel="noopener">https://github.com/andyholmes/gnome-shell-extension-gsconnect/wiki/Installation#install-from-git</a></p><p><code>KDE Connect</code>可以在 <code>Google Play</code> 下载。</p><h2 id="1-安装方式"><a href="#1-安装方式" class="headerlink" title="1. 安装方式"></a>1. 安装方式</h2><p><code>GSConnect</code> 提供了两种安装方式，一种是通过从官方仓库的 <code>release</code> 页面下载最后一个版本的压缩包安装，另一种方式就是克隆官方仓库进行编译。</p><p>第一种方式的方法如下：</p><div class="hljs"><pre><code class="hljs shell">mkdir -p ~/.local/share/gnome-shell/extensionsrm -rf ~/.local/share/gnome-shell/extensions/gsconnect@andyholmes.github.iounzip -o gsconnect@andyholmes.github.io.zip -d ~/.local/share/gnome-shell/extensions/gsconnect@andyholmes.github.io</code></pre></div><p>第二种方法如下：</p><div class="hljs"><pre><code class="hljs shell">git clone https://github.com/andyholmes/gnome-shell-extension-gsconnect.gitcd gnome-shell-extension-gsconnect/meson _build .ninja -C _build install-zip</code></pre></div><p>选择第一种方式更方便，不需要编译，我选择的是第一种方式。</p><p>使用第二种安装方式的时候，编译出现了点问题，缺少两个构建工具：meson， ninja。</p><div class="hljs"><pre><code class="hljs shell">sudo aptitude install meson</code></pre></div><p>同时会安装 meson和ninja。</p><p>开始，构建，报错。</p><div class="hljs"><pre><code class="hljs shell">The Meson build systemVersion: 0.45.1Source dir: /home/aim/SoftWare/gnome-shell-extension-gsconnectBuild dir: /home/aim/SoftWare/gnome-shell-extension-gsconnect/_buildBuild type: native buildmeson.build:1:0: ERROR: Meson version is 0.45.1 but project requires &gt;= 0.49.0.A full log can be found at /home/aim/SoftWare/gnome-shell-extension-gsconnect/_build/meson-logs/meson-log.txt</code></pre></div><p>原来是meson版本低于依赖的版本。安装高版本的meson</p><div class="hljs"><pre><code class="hljs shell">pip install meson==0.49.0</code></pre></div><h2 id="2-开始使用"><a href="#2-开始使用" class="headerlink" title="2. 开始使用"></a>2. 开始使用</h2><p>手机要和电脑处在同一个局域网，不然搜索不到。</p><p>手机打开 <code>Kde Connect</code>，点击 <code>⊕ Pair new device</code> 扫描周围设备进行配对，出现电脑名字的时候点击进行配对，电脑上点击<code>accept</code> 即可配对成功。</p><p>同时，为了方便的管理电脑上的剪切板剪切的文件，安装一个剪切板管理软件。</p><div class="hljs"><pre><code class="hljs shell">sudo aptitude install copyq</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/0516/16107.html"/>
    <url>/2020/0516/16107.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="hljs"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="hljs"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="hljs"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="hljs"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Code</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
