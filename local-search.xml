<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>6月总结</title>
    <link href="/2022/0614/9138.html"/>
    <url>/2022/0614/9138.html</url>
    
    <content type="html"><![CDATA[<h1 id="6月总结"><a href="#6月总结" class="headerlink" title="6月总结"></a>6月总结</h1><h2 id="0x01-多线程"><a href="#0x01-多线程" class="headerlink" title="0x01 多线程"></a>0x01 多线程</h2><p>在公司进行 BUG 处理的时候遇到一个很诡异的问题，流程是这样的：</p><ul><li>前端根据提供搜索参数，后台根据搜索参数在数据库进行过滤查询</li><li>公司使用自己封装的 ORM 框架对数据库进行条件查询</li><li>返回查询出的结果</li></ul><p>问题就出在查询的逻辑中，下面是出现的几个问题。</p><ul><li>切换页码，首次在页面上显示的总条数不一样，从第二页开始固定在一个值。(核心问题)</li><li>时不时回出现  <code>No Column id found</code></li><li>Jpa 出现查询事务报错</li></ul><h3 id="1-并行流与线程安全"><a href="#1-并行流与线程安全" class="headerlink" title="1. 并行流与线程安全"></a>1. 并行流与线程安全</h3><p>先说说 <code>No Column id found</code> 的问题，如下是发生问题的地方，<code>table(TableSchema)</code> 是模型映射到数据库的一个映射类，主要作用于实体类上，<code>FieldSchema</code> 则是属于 <code>table</code> 的映射字段，这里的作用就是取出映射的数据库字段。</p><p>乍一看好像没什么问题，使用内部迭代的方式，写法很简洁，可读性很好，但是这里使用的是 <code>parallelStream</code> 而不是 <code>stream</code>，问题就出在这里，最终取出来的数据库映射字段不是完整的，导致每次进行映射的时候就会出现 <code>No Column id</code> 的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Map&lt;String, FieldSchema&gt; fields = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(table.getKeys().size());<br>table.getKeys().parallelStream().forEach(key -&gt;<br>                                         fields.put(key.getProperty_id(), key));<br></code></pre></td></tr></table></figure><p>这里使用一个例子来展示线程安全的问题：一个很简单的例子，计算数组每个元素的倍数，在多次测试的情况下，得出的总数和原来数组的总数不一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testParallelTrap</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;Integer&gt; data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">10000</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10000</span>; i++) &#123;<br>        data.add(i);<br>    &#125;<br>    List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    data.parallelStream().forEach(key -&gt; result.add(key * <span class="hljs-number">2</span>));<br>    System.out.println(<span class="hljs-string">&quot;the result size is: &quot;</span> + result.size());<br>&#125;<br><br><span class="hljs-comment">// the result size is: 9770</span><br><span class="hljs-comment">// the result size is: 9248</span><br></code></pre></td></tr></table></figure><p>正确的方式是，在 <code>parallelStream</code> 中使用线程安全的容器，或者使用 <code>stream</code> 中的结束方法 <code>collect()</code> 配合 <code>Collectors</code> 的<code>toList(), toMap(),toSet()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 使用并发容器</span><br>Map&lt;String, FieldSchema&gt; tables = <span class="hljs-keyword">new</span> Hashtable();<br>Map&lt;String, FieldSchema&gt; conTables = <span class="hljs-keyword">new</span> ConcurrentHashMap();<br>Map&lt;String, FieldSchema&gt; syncTables = Collections.synchronizedMap(<span class="hljs-keyword">new</span> HashMap&lt;&gt;());<br><br>table.getKeys().parallelStream().forEach(key -&gt;<br>                                         tables.put(key.getProperty_id(), key));<br><br><span class="hljs-comment">// 使用 stream 提供的 toMap 方法，如果是 List 就使用 toList，如果是 Set 就使用 toSet</span><br>Map&lt;String, FieldSchema&gt; fields = table.parallelStream().collect(<br>                Collectors.toMap(FieldSchema::getProperty_id, key -&gt; key));<br></code></pre></td></tr></table></figure><h3 id="2-static-与线程安全"><a href="#2-static-与线程安全" class="headerlink" title="2. static 与线程安全"></a>2. static 与线程安全</h3><p>找了很久，终于发现出现问题的地方了，由于从数据库获取数据到进行数据转换是多线程方式，目的是为了提高搜索效率；由于 <code>findByIds</code> 以及外部是多线程操作，同时 <code>TableSchema</code> 被定义为静态变量，导致多线程获取的表名会出现重复的情况，所以每次从数据库查询获取的总数不一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TableSchema schema;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TableSchema <span class="hljs-title">geSchema</span><span class="hljs-params">(String deviceId)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (deviceId.length() &lt; LENGTH) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">&quot;device id length must greater then 5&quot;</span>);<br>        &#125;<br>        schema.setName(getTableName(deviceId));<br>        <span class="hljs-keyword">return</span> schema;<br>    &#125;    <br>&#125;<br><br><br><span class="hljs-comment">// 这里及其方法外部是多线程操作</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Policy&gt; <span class="hljs-title">findByIds</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String deviceId, <span class="hljs-keyword">final</span> List&lt;UUID&gt; ids)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">final</span> TableSchema schema = Policy.getPolicySchema(deviceId);<br>        Query query = <span class="hljs-keyword">new</span> Query();<br>        query.setSchema(schema);<br>    <span class="hljs-comment">// ....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>多线程中的静态方法：多个线程并发的调用某个类的静态方法，如果静态方法内部没有操作静态成员，那么就不会出现线程安全问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStaticMemberTrap</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-keyword">int</span> finalI = i;<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            Runner.print(finalI);<br>        &#125;);<br>        thread.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runner</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">10</span>;<br>        count = count * number;<br>        System.out.println(<span class="hljs-string">&quot;result: &quot;</span> + count);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">result: 10</span><br><span class="hljs-comment">result: 20</span><br><span class="hljs-comment">result: 30</span><br><span class="hljs-comment">result: 40</span><br><span class="hljs-comment">result: 50</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>但是如果多个线程调用静态方法时，静态方法内部操作了本类的静态成员变量，那么就会出现线程安全问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStaticMemberTrap</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-keyword">int</span> finalI = i;<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            Runner.print(finalI);<br>        &#125;);<br>        thread.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runner</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">10</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        count = count * number;<br>        System.out.println(<span class="hljs-string">&quot;result: &quot;</span> + count);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">result: 10</span><br><span class="hljs-comment">result: 20</span><br><span class="hljs-comment">result: 60</span><br><span class="hljs-comment">result: 240</span><br><span class="hljs-comment">result: 1200</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>对于静态成员变量来说，属于类的成员变量，所有类的对象同时共享，值的修改对于其他对象均可见，不恰当的使用则会造成线程安全问题。解决的方法是，不要在静态方法里面使用类的静态变量，应该在方法内部使用局部变量，才不会造成线程安全的问题。</p><p>对于项目里的代码来说，需要改成如下方式：由于 <code>TableSchema</code> 的数据在静态代码块就已经填充完毕，故使用克隆的形式重新创建一份新的 <code>TableSchema</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TableSchema <span class="hljs-title">getSchema</span><span class="hljs-params">(String deviceId)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (deviceId.length() &lt; LENGTH) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">&quot;设备id必须大于5才合法&quot;</span>);<br>    &#125;<br>    TableSchema cloneAddressSchema = <span class="hljs-keyword">new</span> TableSchema();<br>    BeanUtils.copyProperties(schema, cloneAddressSchema);<br>    cloneAddressSchema.setName(getTableName(deviceId));<br>    <span class="hljs-keyword">return</span> cloneAddressSchema;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="0x02-Spring-JPA"><a href="#0x02-Spring-JPA" class="headerlink" title="0x02 Spring JPA"></a>0x02 Spring JPA</h2><h3 id="1-常用注解"><a href="#1-常用注解" class="headerlink" title="1. 常用注解"></a>1. 常用注解</h3><p><code>@DynamicInsert</code>：作用于使用 <code>@Entity</code> 标注的实体类上，目的是为了插入语句的时候动态插入，当成员变量为空的时候不会参与到插入语句中。</p><p><code>@DynamicUpdate</code>：作用于使用 <code>@Entity</code> 标注的实体类上，目的是为了更新语句的时候动态更新，当成员变量为空的时候不会参与到更新语句中。</p><p><code>@OrderBy</code>：作用于字段，生成 <code>SQL</code> 语句的时候指定特定的字段进行排序。</p><p><code>@GeneratedValue</code>：作用于字段，指定当前实体类主键的生成策略。</p><p><code>@Enumerated</code>：作用于枚举字段，把枚举字段的值映射到数据库的字符串字段。</p><p><code>@Transient</code>：作用于字段，指定字段不会被持久化到数据库。</p><p><code>@TypeDef</code>：作用于类上或 <code>package-info.java</code> 上，搭配 <code>@Type</code> 注解使用。</p><p><code>@TypeDefs</code>：作用于类上或 <code>package-info.java</code> 上，当一个类的字段包含多个不同的自定义映射类型时，可以使用。</p><p><code>@Type</code>：作用于字段上或方法上，定义某字段类型为自定义映射类型，搭配 <code>@TypeDef</code> 注解使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table</span><br><span class="hljs-meta">@TypeDefs(value = &#123;</span><br><span class="hljs-meta">        @TypeDef(name = &quot;jsonb&quot;, typeClass = JsonBinaryType.class)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@DynamicInsert</span><br><span class="hljs-meta">@DynamicUpdate</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> </span>&#123;<br><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-meta">@Column</span><br>    <span class="hljs-keyword">private</span> String city;<br><br>    <span class="hljs-meta">@Column</span><br>    <span class="hljs-keyword">private</span> String area;<br><br>    <span class="hljs-meta">@Column</span><br>    <span class="hljs-keyword">private</span> String street;<br><br>    <span class="hljs-meta">@Type(type = &quot;jsonb&quot;)</span><br>    <span class="hljs-meta">@Column(columnDefinition = &quot;jsonb&quot;)</span><br>    <span class="hljs-keyword">private</span> String detail;<br><br>    <span class="hljs-meta">@Column</span><br>    <span class="hljs-keyword">private</span> Date createdTime;<br><br>    <span class="hljs-meta">@Column</span><br>    <span class="hljs-keyword">private</span> Date updatedTime;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Entity-的生命周期"><a href="#2-Entity-的生命周期" class="headerlink" title="2. Entity 的生命周期"></a>2. Entity 的生命周期</h3><p><img src="https://thorben-janssen.com/wp-content/uploads/2020/07/Lifecycle-Model-1024x576.png" alt="img"></p><p>每个实体在 <code>persistence context</code> 中都存在四种状态：</p><ul><li>New: 新建对象，没有和 <code>persistence context</code> 建立关系，修改实体类数据不会触发更新。</li><li>Transient &amp; Managed: 持久化和被托管状态的对象，通过 <code>EntityManager#persist</code>，<code>JPQL</code>，等查询方式和 <code>persistence context</code> 建立联系，任何实体类的改动都会触发数据库的更新。</li><li>Detached: 游离状态，从 <code>Transient &amp; Managed</code> 状态转变而来，使用 <code>EntityManager#detach</code>，<code>clear</code>，<code>close</code>，<code>evict</code> 等方法均会使实体里从持久化状态转变到游离状态，脱离和 <code>persistence context</code> 的联系，想要重新和 <code>persistence context</code> 建立联系需要使用 <code>EntityManager#merge</code> 方法。</li><li>Removed: 移除状态，使用 <code>EntityManager#remove</code> 可以转换为移除状态，但是数据库记录不会里面删除；在事务提交或 <code>EntityManager#flush</code> 之前 <code>persistence context</code> 会生成删除语句等待删除记录。</li></ul><p><code>Managed</code> 状态下的数据保存，更新以及删除数据下的 <code>Removed</code> 状态，数据都不会立即更新到数据库，只有当你事务提交(<code>@Transactional</code>)或者 <code>em.flush()</code>，才会立即更新到数据库。</p><h3 id="3-Repository-自定义方法与-Transactional-Modifying"><a href="#3-Repository-自定义方法与-Transactional-Modifying" class="headerlink" title="3. Repository 自定义方法与 @Transactional/@Modifying"></a>3. Repository 自定义方法与 <code>@Transactional/@Modifying</code></h3><p>在 JPA <code>Repository</code> 中，可以通过继承 <code>JpaRepository</code> 接口的形式得到现成的CRUD方法，但是有的时候 <code>JpaRepository</code> 中的方法不能满足需求，就需要自定义接口方法。</p><p>需要注意的是，如果自定义(增删改)方法是使用 <code>@Query</code> 的方式，那么需要搭配 <code>@Modifying</code> 注解用于自定义接口方法，告诉 JPA 这是一个增删改语句。同时，不管是使用 <code>@Query</code> 的自定义接口方法或其他自定义接口方法，都应该在业务层的方法中使用 <code>@Transactional</code> 注解修饰。</p><h2 id="0x03-postgresql"><a href="#0x03-postgresql" class="headerlink" title="0x03 postgresql"></a>0x03 postgresql</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>使用 docker 方式快速安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name postgres -p 5432:5432 -e POSTGRES_PASSWORD=123 -v postgres:/var/lib/postgresql/data postgres:latest<br></code></pre></td></tr></table></figure><p>更好的 cli 客户端：<code>pgcli</code>，安装方式如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install pgcli<br></code></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pgcli -h host -u username -d schema<br></code></pre></td></tr></table></figure><p>创建用户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> username <span class="hljs-keyword">WITH</span> PASSWORD <span class="hljs-string">&#x27;*****&#x27;</span>;<br></code></pre></td></tr></table></figure><p>授权数据给刚刚创建的用户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> DATABASE database <span class="hljs-keyword">TO</span> username;<br></code></pre></td></tr></table></figure><p>授权数据库里的表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> <span class="hljs-keyword">all</span> tables <span class="hljs-keyword">in</span> schema public <span class="hljs-keyword">TO</span> username;<br></code></pre></td></tr></table></figure><h3 id="2-常用函数"><a href="#2-常用函数" class="headerlink" title="2. 常用函数"></a>2. 常用函数</h3><p>由于公司项目中的一些数据都存在 <code>postgresql</code> 的 <code>jsonb</code> 字段中，所以有的时候写 <code>sql</code> 查询特别麻烦，记一下常用的 <code>sql</code> 函数。</p><p><code>jsonb_extract_path/jsonb_extract_path_text</code>：从 <code>jsonb</code> 字段中提取某个键的值数据，text结尾标识转换为 <code>text</code> 类型，第一个参数为要提取的 <code>jsonb</code> 数据，第二个字段为提取路径，可选还有第三等等字段(取决于值的深度)，为提取路径的路径。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> jsonb_extract_path_text(<span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">  &quot;id&quot;: 1,</span><br><span class="hljs-string">  &quot;area&quot;: &#123;</span><br><span class="hljs-string">    &quot;name&quot;: &quot;天河区&quot;,</span><br><span class="hljs-string">    &quot;code&quot;: &#123;</span><br><span class="hljs-string">      &quot;type&quot;: &quot;String&quot;,</span><br><span class="hljs-string">      &quot;code&quot;: 1111</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  &#125;,</span><br><span class="hljs-string">  &quot;city&quot;: &quot;广州市&quot;,</span><br><span class="hljs-string">  &quot;detail&quot;: null,</span><br><span class="hljs-string">  &quot;street&quot;: &quot;&quot;,</span><br><span class="hljs-string">  &quot;createdTime&quot;: null,</span><br><span class="hljs-string">  &quot;updatedTime&quot;: null</span><br><span class="hljs-string">&#125;&#x27;</span>::jsonb, <span class="hljs-string">&#x27;area&#x27;</span>, <span class="hljs-string">&#x27;code&#x27;</span>, <span class="hljs-string">&#x27;type&#x27;</span>);<br><br><span class="hljs-comment">-- res</span><br><span class="hljs-comment">-- 1</span><br></code></pre></td></tr></table></figure><p><code>jsonb_array_elements/jsonb_array_elements_text</code>：从 <code>jsonb</code> 数组中遍历并提取每个数组元素。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> fruits <span class="hljs-keyword">from</span> jsonb_array_elements_text(<span class="hljs-string">&#x27;[&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Grape&quot;]&#x27;</span>) <span class="hljs-keyword">as</span> fruits;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Apple</span><br><span class="hljs-comment">Banana</span><br><span class="hljs-comment">Orange</span><br><span class="hljs-comment">Grape</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>jsonb_each/jsonb_each_text</code>：从 <code>jsonb</code> 数据中提取键和值数据，最终结果形成两列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> key, <span class="hljs-keyword">value</span><br><span class="hljs-keyword">from</span> jsonb_each_text(<span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">  &quot;id&quot;: 1,</span><br><span class="hljs-string">  &quot;area&quot;: &#123;</span><br><span class="hljs-string">    &quot;value&quot;: &#123;</span><br><span class="hljs-string">      &quot;name&quot;: &quot;天河区&quot;,</span><br><span class="hljs-string">      &quot;type&quot;: &quot;String&quot;,</span><br><span class="hljs-string">      &quot;code&quot;: 10001</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  &#125;,</span><br><span class="hljs-string">  &quot;city&quot;: &quot;广州市&quot;,</span><br><span class="hljs-string">  &quot;detail&quot;: null,</span><br><span class="hljs-string">  &quot;street&quot;: &quot;&quot;,</span><br><span class="hljs-string">  &quot;createdTime&quot;: null,</span><br><span class="hljs-string">  &quot;updatedTime&quot;: null</span><br><span class="hljs-string">&#125;&#x27;</span>::jsonb)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">id,1</span><br><span class="hljs-comment">area,&quot;&#123;&quot;&quot;value&quot;&quot;: &#123;&quot;&quot;code&quot;&quot;: 10001, &quot;&quot;name&quot;&quot;: &quot;&quot;天河区&quot;&quot;, &quot;&quot;type&quot;&quot;: &quot;&quot;String&quot;&quot;&#125;&#125;&quot;</span><br><span class="hljs-comment">city,广州市</span><br><span class="hljs-comment">detail,</span><br><span class="hljs-comment">street,&quot;&quot;</span><br><span class="hljs-comment">createdTime,</span><br><span class="hljs-comment">updatedTime,</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="3-判断-IP-地址是否包含"><a href="#3-判断-IP-地址是否包含" class="headerlink" title="3. 判断 IP 地址是否包含"></a>3. 判断 <code>IP</code> 地址是否包含</h3><p>在公司里写代码的时候，有判断 IP 地址是否包含的需求，这个时候刚好发现 <code>postgresql</code> 提供此功能，现在记录一下：</p><p>使用 <code>inet</code> 函数可以进行如下操作：<code>inet</code> 不支持 <code>192.168.30.51-12</code> 这种格式，当然这种格式本身就有问题，如果是 <code>192.168.30.1-192.168.30.100</code>，需要使用 <code>split_part()</code> 进行分割。</p><table><thead><tr><th>Operator</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td><code>&lt;</code></td><td>is less than</td><td><code>inet &#39;192.168.1.5&#39; &lt; inet &#39;192.168.1.6&#39;</code></td></tr><tr><td><code>&lt;=</code></td><td>is less than or equal</td><td><code>inet &#39;192.168.1.5&#39; &lt;= inet &#39;192.168.1.5&#39;</code></td></tr><tr><td><code>=</code></td><td>equals</td><td><code>inet &#39;192.168.1.5&#39; = inet &#39;192.168.1.5&#39;</code></td></tr><tr><td><code>&gt;=</code></td><td>is greater or equal</td><td><code>inet &#39;192.168.1.5&#39; &gt;= inet &#39;192.168.1.5&#39;</code></td></tr><tr><td><code>&gt;</code></td><td>is greater than</td><td><code>inet &#39;192.168.1.5&#39; &gt; inet &#39;192.168.1.4&#39;</code></td></tr><tr><td><code>&lt;&gt;</code></td><td>is not equal</td><td><code>inet &#39;192.168.1.5&#39; &lt;&gt; inet &#39;192.168.1.4&#39;</code></td></tr><tr><td><code>&lt;&lt;</code></td><td>is contained within</td><td><code>inet &#39;192.168.1.5&#39; &lt;&lt; inet &#39;192.168.1/24&#39;</code></td></tr><tr><td><code>&lt;&lt;=</code></td><td>is contained within or equals</td><td><code>inet &#39;192.168.1/24&#39; &lt;&lt;= inet &#39;192.168.1/24&#39;</code></td></tr><tr><td><code>&gt;&gt;</code></td><td>contains</td><td><code>inet &#39;192.168.1/24&#39; &gt;&gt; inet &#39;192.168.1.5&#39;</code></td></tr><tr><td><code>&gt;&gt;=</code></td><td>contains or equals</td><td><code>inet &#39;192.168.1/24&#39; &gt;&gt;= inet &#39;192.168.1/24&#39;</code></td></tr><tr><td><code>~</code></td><td>bitwise NOT</td><td><code>~ inet &#39;192.168.1.6&#39;</code></td></tr><tr><td><code>&amp;</code></td><td>bitwise AND</td><td><code>inet &#39;192.168.1.6&#39; &amp; inet &#39;0.0.0.255&#39;</code></td></tr><tr><td>`</td><td>`</td><td>bitwise OR</td></tr><tr><td><code>+</code></td><td>addition</td><td><code>inet &#39;192.168.1.6&#39; + 25</code></td></tr><tr><td><code>-</code></td><td>subtraction</td><td><code>inet &#39;192.168.1.43&#39; - 36</code></td></tr><tr><td><code>-</code></td><td>subtraction</td><td><code>inet &#39;192.168.1.43&#39; - inet &#39;192.168.1.19&#39;</code></td></tr></tbody></table><h2 id="0x04-序列化"><a href="#0x04-序列化" class="headerlink" title="0x04 序列化"></a>0x04 序列化</h2><h3 id="1-对象之间互相引用导致序列化栈溢出"><a href="#1-对象之间互相引用导致序列化栈溢出" class="headerlink" title="1. 对象之间互相引用导致序列化栈溢出"></a>1. 对象之间互相引用导致序列化栈溢出</h3><p>在使用 <code>JPA</code> 进行一对多处理的时候，模型定义如下：一个作者可以有多本图书，多个图书对应一本读书，两个实体类之间存在互相引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.AUTO)</span><br>    <span class="hljs-keyword">private</span> Integer id;<br><br>    <span class="hljs-meta">@Column</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@OneToMany(mappedBy = &quot;author&quot;, fetch = FetchType.EAGER)</span><br>    <span class="hljs-keyword">private</span> List&lt;Book&gt; bookList;<br>&#125;<br><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.AUTO)</span><br>    <span class="hljs-keyword">private</span> Integer id;<br><br>    <span class="hljs-meta">@Column</span><br>    <span class="hljs-keyword">private</span> String title;<br><br>    <span class="hljs-meta">@ManyToOne(fetch = FetchType.EAGER)</span><br>    <span class="hljs-keyword">private</span> Author author;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码：无论是序列化 Book 还是 Author，都会触发 <code>com.fasterxml.jackson.databind.JsonMappingException: Infinite recursion (StackOverflowError) </code> 的报错，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testReferenceError</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;<br>    Author author = <span class="hljs-keyword">new</span> Author();<br>    author.setId(<span class="hljs-number">1</span>);<br>    author.setName(<span class="hljs-string">&quot;东野圭吾&quot;</span>);<br><br>    Book book1 = <span class="hljs-keyword">new</span> Book();<br>    book1.setId(<span class="hljs-number">1</span>);<br>    book1.setAuthor(author);<br>    book1.setTitle(<span class="hljs-string">&quot;虚无的十字架&quot;</span>);<br>    Book book2 = <span class="hljs-keyword">new</span> Book();<br>    book2.setId(<span class="hljs-number">2</span>);<br>    book2.setAuthor(author);<br>    book2.setTitle(<span class="hljs-string">&quot;湖畔&quot;</span>);<br><br>    author.setBooks(Arrays.asList(book1, book2));<br>    ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();<br>    <span class="hljs-comment">// String asString = mapper.writeValueAsString(book1);</span><br>    String asString = mapper.writeValueAsString(author);<br>    System.out.println(asString);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-前后端Long的处理"><a href="#2-前后端Long的处理" class="headerlink" title="2. 前后端Long的处理"></a>2. 前后端Long的处理</h3><p>在公司开发的时候，在与前后端联调的时候碰到一个数据类型序列化的问题，Java 传递一个 Long 类型的数据时，对于前端而言，<code>Javascript</code> 无法处理 Long 类型的数据，会导致精度丢失，下面是几种解决方法：</p><p>使用 <code>jackson</code> 的 <code>@JsonSerialize</code> 用于实体类的 Long 字段上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@JsonSerialize(using = ToStringSerializer.class)</span><br><span class="hljs-keyword">private</span> Long id;<br></code></pre></td></tr></table></figure><p>使用 <code>jackson</code> 的 <code>@JsonFormat</code> 用于实体类的 Long 字段上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@JsonFormat(shape = JsonFormat.Shape.STRING)</span><br><span class="hljs-keyword">private</span> Long id;<br></code></pre></td></tr></table></figure><p>前面两种方式都是作用于实体类的字段，每个实体类都要设置一遍，特别麻烦，下面是针对整个项目全局的配置：通过实现 <code>WebMvcConfigurer#configureMessageConverters</code> 接口方法，配置整个项目全局的 Long 类型转换。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@EnableWebMvc</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureMessageConverters</span><span class="hljs-params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;<br>        MappingJackson2HttpMessageConverter jackson2HttpMessageConverter = <span class="hljs-keyword">new</span> MappingJackson2HttpMessageConverter();<br>        ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();<br>        SimpleModule simpleModule = <span class="hljs-keyword">new</span> SimpleModule();<br>        simpleModule.addSerializer(Long.class, ToStringSerializer.instance);<br>        simpleModule.addSerializer(Long.TYPE, ToStringSerializer.instance);<br>        objectMapper.registerModule(simpleModule);<br>        jackson2HttpMessageConverter.setObjectMapper(objectMapper);<br>        converters.add(jackson2HttpMessageConverter);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-反序列化无视未知字段"><a href="#3-反序列化无视未知字段" class="headerlink" title="3. 反序列化无视未知字段"></a>3. 反序列化无视未知字段</h3><p>公司主要使用 <code>jackson</code> 进行序列化和反序列化处理，主要原因是 <code>SpringBoot</code> 自带，以及 <code>jackson</code> 支持Java接口类型 <code>json</code> 动态序列化和反序列化</p><p>在一次对数据库中的 <code>json</code> 字段数据进行反序列化的过程中，发现报了一个错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field &quot;age&quot; (class com.root2z.practice.model.Person), not marked as ignorable (2 known properties: &quot;id&quot;, &quot;name&quot;])<br> at [Source: (String)<span class="hljs-string">&quot;&#123;&quot;</span>id<span class="hljs-string">&quot;:1,&quot;</span>name<span class="hljs-string">&quot;:&quot;</span>mike<span class="hljs-string">&quot;,&quot;</span>age<span class="hljs-string">&quot;:12&#125;&quot;</span>; line: <span class="hljs-number">1</span>, column: <span class="hljs-number">31</span>] (through reference chain: com.root2z.practice.model.Person[<span class="hljs-string">&quot;age&quot;</span>])<br></code></pre></td></tr></table></figure><p>这里的意思是说在反序列化 <code>json</code> 的时间检测到了为识别的 <code>json</code> 字段映射到 <code>Person</code> 类上，这里 <code>json</code> 中的 <code>age</code> 字段在 <code>Person</code> 类中是没有定义的，序列化就会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-meta">@Id</span> <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-meta">@Column</span> <span class="hljs-keyword">private</span> String name;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deserializeUnknownField</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;<br>    String json = <span class="hljs-string">&quot;&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;mike\&quot;,\&quot;age\&quot;:12&#125;&quot;</span>;<br>    ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();<br>    Person person = objectMapper.readValue(json, Person.class);<br>    System.out.println(person);<br>&#125;<br></code></pre></td></tr></table></figure><p>解决的方法：</p><ul><li>在类上使用 <code>@JsonIgnoreProperties(ignoreUnknown = true)</code> 注解告诉 <code>jackson</code> 无视 <code>json</code> 中未知字段</li><li>使用 <code>ObjectMapper</code> 配置 <code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code> 属性。</li></ul><p>方法1的标记在需要反序列化的类上，主要每个需要反序列化的类都需要设置一遍，通常是使用第二种方式，设置全局的 <code>ObjectMapper</code> 属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@JsonIgnoreProperties(ignoreUnknown = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-meta">@Id</span> <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-meta">@Column</span> <span class="hljs-keyword">private</span> String name;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deserializeUnknownField</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;<br>    String json = <span class="hljs-string">&quot;&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;mike\&quot;,\&quot;age\&quot;:12&#125;&quot;</span>;<br>    ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();<br>    objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="hljs-keyword">false</span>);<br>    Person person = objectMapper.readValue(json, Person.class);<br>    System.out.println(person);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="0x05-其他"><a href="#0x05-其他" class="headerlink" title="0x05 其他"></a>0x05 其他</h2><h3 id="1-代码规范"><a href="#1-代码规范" class="headerlink" title="1. 代码规范"></a>1. 代码规范</h3><h4 id="1-集合判空"><a href="#1-集合判空" class="headerlink" title="(1). 集合判空"></a>(1). 集合判空</h4><p>不要使用集合的 <code>isEmpty()</code> 方法来判空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindAllAddresses</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;Address&gt; addresses = addressService.findAll();<br>    <span class="hljs-comment">// 要是 addresses 为空，那么就会 NullPointException</span><br>    <span class="hljs-keyword">if</span> (addresses.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>正确的方式：应该同时判断 <code>null</code> 和 <code>isEmpty()</code>，或者使用第三方的 <code>CollectionUtils.isEmpty</code> 来判空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindAllAddresses</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;Address&gt; addresses = addressService.findAll();<br>    <span class="hljs-comment">// 要是 addresses 为空，那么就会 NullPointException</span><br>    <span class="hljs-comment">// if (addresses.isEmpty() || addresses == null) &#123;</span><br>    <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(addresses)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-异常捕捉"><a href="#2-异常捕捉" class="headerlink" title="(2). 异常捕捉"></a>(2). 异常捕捉</h4><p>不应该把异常捕获不抛出：捕获了异常，不进行处理，也不抛出，在错误定位时也无法定位，用户也无法感知到错误，这是不正确的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetAddressById</span><span class="hljs-params">(id)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Address address = addressService.getAddress(<span class="hljs-number">1L</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>        <span class="hljs-comment">// do nothing</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>正确的方式，转换成系统自定义的异常，同时携带上下文信息：</p><blockquote><p>tips：在 <code>catch</code> 里抛出了异常就不需要打印异常日志了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetAddressById</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> NotFoundAddressException</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Address address = addressService.getAddress(id);<br>    &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>        <span class="hljs-comment">// 携带找不到地址信息的ID</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotFoundAddressException(String.format(<span class="hljs-string">&quot;cannot found address by id:%s&quot;</span>, id));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-if-for-嵌套消除"><a href="#3-if-for-嵌套消除" class="headerlink" title="(3). if/for 嵌套消除"></a>(3). if/for 嵌套消除</h4><h3 id="2-第三方库隔离"><a href="#2-第三方库隔离" class="headerlink" title="2. 第三方库隔离"></a>2. 第三方库隔离</h3><blockquote><p>第三方库的滥用，这就是多人开发中通常会碰到的问题。</p></blockquote><p>对于个人开发的项目来说，我可以自由的选择第三方框架和库，控制权属于自己手上，这没问题，我清楚使用了什么库以及在哪里使用。</p><p>但是对于团队而言，还能以这种方式开发么，明显不能，每个人都有自己的编码风格，每个人都有自己擅长使用的库，假设每个人都在开发时都使用自己喜欢的第三方库辅助，那么整个工程将是混乱的。</p><p>假设是下面一个对从数据库取出的数据判空的情况，每个人可能有不同的写法，可能使用 <code>Spring</code> 的 <code>CollectionUtils</code> ，也有可能使用 <code>apache</code> 的 <code>CollectionUtils</code> ，每个库的 <code>CollectionUtils</code> 的 <code>isEmpty</code> 方法(参数类型，参数个数)可能不一样，这个时候，要是别人直接复制过来，刚好这里又已经引入了 <code>CollectionUtils</code> 的包，方法必然是会报错的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> org.springframework.util.CollectionUtils;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.CollectionUtils;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindAllAddresses</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;Address&gt; addresses = addressService.findAll();<br>    <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(addresses)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候就有必要进行第三方库的隔离，好处呢：</p><ul><li>屏蔽第三方库的公共调用，由封装模块实现内部调用第三方库的细节</li><li>由于屏蔽了第三方库的公共调用，每个人调用封装库即可，即使替换第三方库也不影响开发。实现第三方库的平滑替换。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionUtils</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Collection&lt;?&gt; collection)</span> </span>&#123;<br>        <span class="hljs-comment">// 随时替换第三方库</span><br>        <span class="hljs-keyword">return</span> org.springframework.util.CollectionUtils.isEmpty(collection);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNotEmpty</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Collection&lt;?&gt; collection)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> !CollectionUtils.isEmpty(collection);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是个人开发的项目，也需要做到第三方库的隔离么？对于开发规范以及软件的扩展性和伸缩性是有必要做的。</p><h2 id="0x06-闲谈"><a href="#0x06-闲谈" class="headerlink" title="0x06 闲谈"></a>0x06 闲谈</h2><p>人生第一次经历两次裁员，虽然这事不是发生在我身上，但是我觉得心情还是有点复杂，曾经是一起工作的同事，隔日就要开始为工作奔波。说到底，源头还是疫情的原因，公司面临经济危机才做出的下策，大家都能理解。</p><p>我还记得走之前，组长跟我说到，不要着眼于眼前的东西，多接触几个领域，关注关注 web3.0，区块链等等。</p><p>我现在想做的就是，做好基础建设，语言，算法，消息队列，分布式，技术前沿。</p><p>最近断断续续通关了两个游戏，一个是 FireWatch，一个是 Inside。</p><p><a href="https://imgtu.com/i/X4YoEF"><img src="https://s1.ax1x.com/2022/06/14/X4YoEF.jpg" alt="X4YoEF.jpg"></a></p><p>FireWatch 的色彩风格真是特别的好看，同时游戏本身属于半开放世界游戏，可以随时的停止对话，也就是说可以当一个走路模拟器。中期的时候夹杂着一些悬疑情节，一度让我以为这要变成恐怖游戏了，不过还好没有。</p><p>整个游戏带给我最大的感受是：孤独。作为一个看火人，整个山谷内除了和主角对话的 Deliah 以及失去儿子的 Ned 之外几乎没有任何动物和人。</p><p>主角因为妻子所患阿尔茨海默症无能为力之后选择到俄怀明州的山谷当一名看火人，以此来自我放逐和避世，期间和另一名看火人 Deliah 又互相吸引，Deliah 也是因为某种原因选择当看火人来逃避，两人经历七十九天从陌生到熟悉，我本以为最后会发生什么，结果确没有。</p><p>结尾的一场大火，使得两个人都要离开山谷，这场大火烧毁了两个以此来逃避的安乐园，也烧毁了他们对过去的留念，人总是要往前看的。经历过大火之后，森林也会重新长出萌芽，而他们也会有新的开始。</p><p><a href="https://imgtu.com/i/X4ghKU"><img src="https://s1.ax1x.com/2022/06/14/X4ghKU.jpg" alt="X4ghKU.jpg"></a></p><p><a href="https://imgtu.com/i/X4RCmF"><img src="https://s1.ax1x.com/2022/06/14/X4RCmF.png" alt="X4RCmF.png"></a></p><p>Inside，全程没有对话，解谜难度简单，剧情很不错，结局很震撼。</p><p><a href="https://imgtu.com/i/X4fPi9"><img src="https://s1.ax1x.com/2022/06/14/X4fPi9.jpg" alt="X4fPi9.jpg"></a></p><p><a href="https://imgtu.com/i/X4fZqO"><img src="https://s1.ax1x.com/2022/06/14/X4fZqO.jpg" alt="X4fZqO.jpg"></a></p><p><a href="https://imgtu.com/i/X4WR2t"><img src="https://s1.ax1x.com/2022/06/14/X4WR2t.jpg" alt="X4WR2t.jpg"></a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/0404/16107.html"/>
    <url>/2022/0404/16107.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再见,2021</title>
    <link href="/2022/0109/24084.html"/>
    <url>/2022/0109/24084.html</url>
    
    <content type="html"><![CDATA[<h1 id="2021-年末总结"><a href="#2021-年末总结" class="headerlink" title="2021 年末总结"></a>2021 年末总结</h1><iframe     frameborder="no" border="0" marginwidth="0"     marginheight="0" width="100%" height=86     src="//music.163.com/outchain/player?type=2&id=18533095&auto=0&height=66"></iframe><h2 id="书影音"><a href="#书影音" class="headerlink" title="书影音"></a>书影音</h2><h3 id="看过的书"><a href="#看过的书" class="headerlink" title="看过的书"></a>看过的书</h3><p>这一年看的纸质书比较少，不过有一本倒是反复看了两次，就是 <code>Java编程思想</code>，作为 <code>Java</code> 当中圣经一般的存在，无疑是值得反复看的，每次翻的时候感觉都会有不同的体验，不过现在已经出了第五版，第五版相对第四版而言就是把讲述大量 <code>Java GUI</code> 的章节删掉了，增加了函数式编程等等章节，个人感觉函数式编程应该更值得被加进来，毕竟相对来说使用 <code>Java</code> 做 <code>UI</code> 界面的感觉比较少。</p><p>因为纸质书看的比较少，平时都是在微信读书和Kindle上看，看了如下书</p><ul><li>殉罪者</li><li>1367</li><li>网内人</li><li>镖人</li><li>无聊的人生，我死也不要(北野武自述)</li><li>Netty 实战</li><li>Java 8 实战</li></ul><p>去年看完了雷米的心理罪全册，今年倒是只看了他的另一部小说殉罪者，多线叙事，就是结尾感觉有点差强人意。</p><p>从这之后，我就开始看一些推理类的小说，例如接下来的网内人，作者本身是计算机专业的，然后书内又大量使用了计算机网络/计算机安全的专业术语以及解释，学计算机的看着是非常亲切，当然推理部分也是非常棒；看过网内人之后，我又去看了 1367，没想到第一篇就直接震撼，诡计设计的太巧妙了，六个时间线六个故事，讲完了关振铎的一生，也讲完了香港1967-2013的变化，最后一个故事的伏笔和第一个故事竟然还又串起来了。</p><p>镖人我哥之前看过，我也听说过这部国漫挺有名的，刚开始看的时候有点不适应，觉得画风有点奇怪，后面就慢慢适应了，漫画讲的是隋唐时期的故事，还好我是文科生，不至于看着有点晕，不过有些历史人物是没了解过，例如斐世矩，后面看到杨广拟态那段震惊了；貌似现在还在更新，继续追更(😋)。</p><p>尝试过在微信读书上和 Kindle 上看技术书籍，要是偏概念性的技术书籍还好，但要是碰到那种一言不合就堆叠一堆代码的，那对阅读将是一个灾难，明年买个平板方便阅读此类书籍(🤗)。</p><h3 id="影音"><a href="#影音" class="headerlink" title="影音"></a>影音</h3><ul><li>信条</li><li>人之怒</li><li>千钧一发</li><li>非常嫌疑犯</li><li>超脱</li><li>看不见的客人</li><li>申冤人</li><li>绝命毒师 Season3</li><li>耶路撒冷地</li></ul><p>今年没怎么看剧，有好多剧弃坑了直接没看，不死法医、飞天大盗、冰雪暴、亚瑟罗宾…，然后打算明年捡回来，不过保持了每周看一部电影的频率，希望明年继续保持。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>下半年来到深圳实习，陆陆续续找了半个月，那半个月很难熬，虽说家里人没有给我太大压力，甚至说是没有，但是我自己给自己压力，期望着能尽快找到。每一次面试都很累，四处奔走，好在有同学暂时能让我住宿，我不至于担心住哪里的问题。</p><p>没有面试的时候我就会去深圳湾走走，暂时给自己放松一下，后面有工作了也偶尔会去那里散散步，不得不说那里风景还是很好看的，下面是晚上拍的照片(😆)。</p><p><img src="https://buckets-me.oss-cn-beijing.aliyuncs.com/gitblog/webwxgetmsgimg.jpeg"></p><p>总的来说，在公司还是学到了一点知识，对项目模块的划分，一些逻辑封装的思想，对某个功能点完整性的思考，这些对我受益很大。</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>今年 <code>Java</code> 写的比较多，很大一部分时间是在写自己的项目，然后 <code>Python</code> 的话，也就没怎么写了，除了在年初的时候和室友写过一个小工具，之后就不太使用 <code>Python</code> 了，但是 <code>Python</code> 依然是我的主力语言，和 <code>Java</code> 一样。</p><p>今年学习技术的重心也渐渐不再最求新的框架和新的技术，而是把现有的框架学好，并且侧重于一些理论性，偏业务的一些知识，也看过这样的几篇文章，还是帮助挺大的。</p><p>我在年底的一两个月，尝试过每周阅读一个开源项目的代码，并且从中抽取一些知识点，做成笔记，亦或是对这个开源项目作出自己的贡献，但是发现太高估自己了，一周一个，属实有点太快，一个礼拜可能也不能完整的吸收整个项目，明年的话，打算把这个延长为半个月。</p><p>年底的时候考虑过一个独立项目，并且是想做成一个持续的开源项目，但是还只是一个想法：</p><blockquote><p>云帐，基于云的一个账单管理，并且同时有多端:</p><ul><li>Web</li><li>Android</li><li>微信小程序</li><li>…</li></ul></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><img src="https://buckets-me.oss-cn-beijing.aliyuncs.com/gitblog/IMG_20220109_093839.jpg"></p><p>小时候喜欢过魔术，但随着时间的推移渐渐的忘记了这个兴趣，今年的时候看到刘谦在B站，然后发现前年就入驻了，又打算学习魔术。前年买的一副牌本来是想<a href="https://zh.wikipedia.org/zh-sg/%E8%8A%B1%E5%88%87">花切</a>的，然后发现手太残，只练了几个手法就没练了，后面觉得把，可能纸牌魔术更简单点，不需要太多手法(然而事实上我也想错了😂)。</p><p>魔术有好多个领域，我选择了一个相对简单的领域，纸牌魔术，随时随地都能变，今年也学习了几个流程和手法：</p><ul><li>双翻 (Double Lift)</li><li>控牌 (Control Card)</li><li>错引 (Misdirection)</li><li>假洗 (False Shuffle)</li><li>假切 (False Cut)</li><li>假数 (False Count)</li><li>….</li><li>Biddle Trick</li><li>Card Transfer</li><li>….</li></ul><p>我在公司聚餐的时候表演过几个流程化的魔术，有一两次差点露馅了(😓)，其中一个纸牌传送的流程还是我自己结合四五个手法创造出来的，但是后面逛B站的时候才发现老早就有这个手法了(🤣)。</p><h2 id="2022-Flag-🤔"><a href="#2022-Flag-🤔" class="headerlink" title="2022 Flag (🤔)"></a>2022 Flag (🤔)</h2><p>给自己的 2022 立一些 Flag：</p><ul><li>尝试每个月学习一个流程，在陌生人/认识的人面前表演。</li><li>保持每周看一部电影</li><li>把那个独立项目变成现实</li><li>阅读更多的书</li><li>使用 <code>obsidian</code> 构建个人Wiki</li></ul><p>最后，<strong>stay hungry stay foolish</strong>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记一次博客部署</title>
    <link href="/2021/0820/53427.html"/>
    <url>/2021/0820/53427.html</url>
    
    <content type="html"><![CDATA[<h1 id="一次博客部署的经历"><a href="#一次博客部署的经历" class="headerlink" title="一次博客部署的经历"></a>一次博客部署的经历</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在六七月份前前后后花了一个多月写一个博客项目，但是我还没有在真实环境部署过项目的经历，正好现在已经部署完了，就把部署过程写下来吧，以后忘记怎么部署了还可以看看。:)</p><h2 id="二、服务器-域名购买"><a href="#二、服务器-域名购买" class="headerlink" title="二、服务器/域名购买"></a>二、服务器/域名购买</h2><p>考虑到国内的服务器和域名还是比较便宜的，所以就选择了在国内购买服务器和域名。我购买的是阿里云的服务器以及域名。</p><p>为域名配置好了 <code>www</code> 记录，让域名指向我购买的服务器 <code>IP</code> 地址。</p><h2 id="三，服务器相关配置"><a href="#三，服务器相关配置" class="headerlink" title="三，服务器相关配置"></a>三，服务器相关配置</h2><p>购买服务器的第一件事就是配置 <code>ssh</code> 远程连接。首先修改服务器的 <code>/etc/ssh/sshd_config</code>，修改如下配置。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 禁止密码登录</span><br>PasswordAuthentication no<br><span class="hljs-comment"># 关闭 root 登录</span><br>PermitRootLogin no<br><span class="hljs-comment"># 修改 ssh 端口</span><br>Port 2022<br></code></pre></td></tr></table></figure><p>这些配置防止一些频繁的暴力破解攻击，接下来在本地生成公私钥对。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 如果没特殊需求可以一路回车</span><br>ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p>把私钥留在本地，上传公钥到服务器，并且将公钥中的内容导入 <code>.ssh/authorized_keys</code> 中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp .ssh/id_rsa.pub root@xx.xx.xx.xx:/root/. <br><br>cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><p>这个时候还不可以登录，因为修改了默认的 22 端口，默认 22 是被阿里云的安全组放行的，但我修改的端口是没被阿里云的安全组放行的，所以要配置安全组规则。</p><p>找到安全组设置，手动添加一条规则，优先级任意，协议类型为自定义 <code>TCP</code>，目的为 2022，源为：<code>0.0.0.0/0</code>，保存。</p><p>重启 <code>ssh</code> ，退出服务器，采用密钥登录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">service ssh restart<br><br><br><span class="hljs-meta">#</span><span class="bash"> 采用密钥登录</span><br>ssh -i ~/.ssh/id_rsa root xx.xx.xx.xx<br><br>vim /etc/ssh/ssh_config<br><span class="hljs-meta">#</span><span class="bash"> 取消下面这行的注释，配置私钥默认路径</span><br>IdentityFile ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure><p>当然有了这些还不够，所以还可以使用 <code>fail2ban</code> 来做更强力的防护。</p><p>安装 <code>fail2ban</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get install fail2ban<br></code></pre></td></tr></table></figure><p>检查 <code>fail2ban</code> 是否启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl status fail2ban<br></code></pre></td></tr></table></figure><p>在 <code>/etc/fail2ban/jail.d/</code> 中创建一个 <code>sshd.local</code>，也就是创建一个新的监狱规则。<code>fail2ban</code> 最终会读取这个 监狱配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">[sshd]<br><span class="hljs-meta">#</span><span class="bash"> 是否启用，不启用则为 <span class="hljs-literal">false</span></span><br>enabled = true<br><br><span class="hljs-meta">#</span><span class="bash"> 如果 SSH 是其他端口，需要在这里修改</span><br>port = ssh<br><br><span class="hljs-meta">#</span><span class="bash"> 存储日志文件的路径</span><br>logpath = %(sshd_log)s<br><br><span class="hljs-meta">#</span><span class="bash"> 最大尝试次数</span><br>maxretry = 3<br><br><span class="hljs-meta">#</span><span class="bash"> 拦截时间</span><br>bantime = 172800<br><br><span class="hljs-meta">#</span><span class="bash"> 过滤规则</span><br>filter = sshd<br><br><span class="hljs-meta">#</span><span class="bash"> 过滤的时长（秒）</span><br>findtime = 3600 <br><br><span class="hljs-meta">#</span><span class="bash"> 执行的动作</span><br>action = iptables[name=SSH, port=ssh, protocol=tcp]<br></code></pre></td></tr></table></figure><p>重启 <code>fail2ban</code>，并且查看规则。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">fail2ban-client reload<br><br>fail2ban-client status sshd <br></code></pre></td></tr></table></figure><h2 id="三，项目部署"><a href="#三，项目部署" class="headerlink" title="三，项目部署"></a>三，项目部署</h2><p>在本地进行 <code>maven</code> 打包，并且上传到服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">maven package<br><br>scp target/MyBlog.jar  root@xx.xx.xx.xx:/root/.<br></code></pre></td></tr></table></figure><p>在服务器中安装 <code>jre</code>，由于只是每次部署到服务器的都是编译好的，所以只需安装 <code>jre</code> 即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt-get install default-jre<br></code></pre></td></tr></table></figure><p>安装数据库，这里安装的是 <code>mariadb</code> 数据库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt-get install mariadb-server <br></code></pre></td></tr></table></figure><p>进行 <code>mariadb</code> 初始化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mysql_secure_installation<br></code></pre></td></tr></table></figure><p>修改 <code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>  配置数据库的字符集编码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[client]<br>default-character-set=utf8<br><br>[mysqld]<br>character-set-server=utf8<br>collation-server=utf8_general_ci<br><br>[mysql]<br>default-character-set=utf8<br></code></pre></td></tr></table></figure><p>由于高版本 (8) 的 <code>mysql</code> 加密规则是 <code>caching_sha2_password</code>，会导致普通用户连接不上，所以这里修改加密规则为 <code>mysql_native_password</code>，首先以 <code>root</code> 环境登录进 <code>mysql</code> 交互终端，执行以下命令。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE mysql.user SET plugin &#x3D; &#39;mysql_native_password&#39; WHERE user &#x3D; &#39;root&#39; AND plugin &#x3D; &#39;unix_socket&#39;;<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><p>退出 <code>mysql</code> ，重启。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo /etc/init.d/mysql restart <br></code></pre></td></tr></table></figure><p>创建相应的数据库并且导入相应的数据库脚本和数据脚本。</p><p>由于每次启动都需要写很长的命令，所以写一个脚本，方便运行。</p><p>启动脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>name=MyBlog.jar<br>nohup java -jar $&#123;name&#125; &amp;<br></code></pre></td></tr></table></figure><p>暂停脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>port=8080<br><span class="hljs-meta">#</span><span class="bash">根据端口号查询对应的pid</span><br>pid=$(netstat -nlp | grep :$port | awk &#x27;&#123;print $7&#125;&#x27; | awk -F&quot;/&quot; &#x27;&#123; print $1 &#125;&#x27;);<br><br>echo &quot;pid=$pid&quot;<br><span class="hljs-meta">#</span><span class="bash">杀掉对应的进程，如果pid不存在，则不执行</span><br>if [  -n  &quot;$pid&quot;  ];  then<br>    echo &quot;正在执行kill命令...&quot;<br>    if kill  -9  $pid; then<br>       echo &quot;执行成功&quot;<br>    fi<br>fi<br></code></pre></td></tr></table></figure><p>更改 <code>start.sh</code> 和 <code>stop.sh</code> 的权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod u+x start.sh<br>chmod u+x start.sh<br></code></pre></td></tr></table></figure><p>找到安全组设置，手动添加一条规则，优先级任意，协议类型为自定义 <code>TCP</code>，目的为 8080，源为：<code>0.0.0.0/0</code>，保存。</p><p>执行 <code>start.sh</code> 脚本，打开浏览器输入服务器 <code>IP</code> 地址 + 8080，即能看到效果。</p><h2 id="四，反向代理与HTTPS"><a href="#四，反向代理与HTTPS" class="headerlink" title="四，反向代理与HTTPS"></a>四，反向代理与HTTPS</h2><p>为了让项目更好的访问以及安全性，接下来配置 <code>nginx</code> 和 <code>https</code>，不过这两个前提都是，服务器需要先备案。</p><h3 id="1-备案"><a href="#1-备案" class="headerlink" title="1. 备案"></a>1. 备案</h3><p>首先域名是要进行实名认证的，才能进行 <code>ICP</code> 备案，这个实名认证很快。</p><p>然后找到阿里云中的 <strong>备案服务号申请</strong>，右侧是 <code>ECS</code> 名称，在下方列表中选择当前实例，进行申请。</p><blockquote><p>基本都是填一下基本个人信息进行核验，然后就是一些主办者信息(我这里主办者是个人)，网站信息，就是描述这个网站是干什么用的( 由于我写的是博客相关的关键字，后来有客服来打电话帮我修改= = )，后面就是上传个人身份证正反面以及人脸识别，最后信息校验，进入 <code>ICP</code> 备案初审。</p><p>差不过隔了一天，就收到了 <strong>阿里云</strong> 的短信，提示备案订单已经提交交管局审核，去工信部验证页面使用刚才的短信验证码验证。</p><p>隔天之后，收到 <strong>工信部</strong> 的短信，告诉我备案已经成功并且给了备案号，这个需要放入网站的底部中间位置。</p></blockquote><h3 id="2-Nginx-配置与安装"><a href="#2-Nginx-配置与安装" class="headerlink" title="2. Nginx 配置与安装"></a>2. Nginx 配置与安装</h3><p><code>nginx</code> 安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt-get install nginx<br></code></pre></td></tr></table></figure><p>修改 <code>/etc/nginx/nginx.conf</code>，加入以下配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">server &#123;<br>    listen 80;<br>    server_name youdomain;<br>    <br>    location / &#123;<br>        proxy_pass http://127.0.0.1:8080; # 端口要对应<br>        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>        proxy_set_header X-Forwarded-Proto $scheme;<br>        proxy_set_header X-Forwarded-Port $server_port;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启 <code> nginx</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo nginx -s reload<br></code></pre></td></tr></table></figure><p>找到安全组设置，手动添加一条规则，优先级任意，协议类型为自定义 <code>TCP</code>，目的为 80，源为：<code>0.0.0.0/0</code>，保存。</p><p>打开浏览器，输入 域名 即可访问到网站，但此时还不是 HTTPS 的 </p><h3 id="3-HTTPS-配置"><a href="#3-HTTPS-配置" class="headerlink" title="3. HTTPS 配置"></a>3. HTTPS 配置</h3><p>要配置 <code>https</code> 首先要有 <code>ssl</code> 证书，这里证书是通过阿里云免费获取。</p><p><img src="https://segmentfault.com/img/bV2L74?w=2398&h=1424" alt="clipboard.png"></p><p>当申请完成后，在证书管理的列表中选择已申请的证书，进行下载，选择 <code>nginx</code> 格式下载。</p><p>上传到服务器的 <code>/usr/local/nginx/cert</code> 下，一个文件为 <code>pem</code> 后缀的，一个文件为 <code>key</code> 后缀的。</p><p>修改 <code>/etc/nginx/nginx.conf</code> 配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">server &#123;<br>    listen 80; #监听80 http 重定向到https<br>    server_name you domain;<br>    # 强制转到 https<br>    rewrite ^(.*)$ https://$&#123;server_name&#125;$1 permanent;<br>&#125;<br><br>server &#123;<br>    listen 443 ssl; #监听443 https<br>    server_name you domain; #配置域名<br>    ssl_certificate cert/xxx.pem; #配置证书位置<br>    ssl_certificate_key cert/xxx.key; #配置证书位置<br>    location / &#123;<br>        proxy_pass http://localhost:8080; # 要反向代理的服务器<br>        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>        proxy_set_header X-Forwarded-Proto $scheme;<br>        proxy_set_header X-Forwarded-Port $server_port;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启 <code> nginx</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo nginx -s reload<br></code></pre></td></tr></table></figure><p>找到安全组设置，手动添加一条规则，优先级任意，协议类型为自定义 <code>TCP</code>，目的为 443，源为：<code>0.0.0.0/0</code>，保存。</p><p>打开浏览器，输入 <code>https:// + 域名</code> ，就可以看到右上角的小绿锁咯。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Nginx</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈上下文</title>
    <link href="/2021/0326/10778.html"/>
    <url>/2021/0326/10778.html</url>
    
    <content type="html"><![CDATA[<h1 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h1><p>写 <code> Python</code> 也好久了，在编写代码时，通常会用到一个表达式，<code>with .... as .....</code>，其中用的最多的可能是打开文件的时候使用这个表达式，但是却没想过为什么要这样写，或者这样写有什么方便之处，今天就来复习一下。</p><h2 id="一、上下文管理器"><a href="#一、上下文管理器" class="headerlink" title="一、上下文管理器"></a>一、上下文管理器</h2><p>何为上下文，在自然语言中，给你一段话，如果没有在上文和下文的情况下，你无法判断这段话在讲什么，也看不懂；这在计算机里也是如此，当一个程序独立存在的时候，它不依赖任何外部的数据或变量，此时它就不存在上下文，但是当多个程序关联起来，互相引用各自的数据或变量时，那么每个程序都不能独自运行了，这个时候就需要一个上下文，来管理这些各自的外部数据和变量。</p><p>而在 <code>Python</code> 中，则有了一个上下文管理器的概念，是指实现了 <code>__enter__()</code> 方法和 <code>__exit__()</code>方法的对象；同时上下文管理器的存在也是为了管理 <code>with</code> 语句。</p><h2 id="二、with-表达式的使用"><a href="#二、with-表达式的使用" class="headerlink" title="二、with 表达式的使用"></a>二、<code>with</code> 表达式的使用</h2><p>在 <code>with</code> 表达式出现之前，对于资源的管理通常使用三段式的方式来实现，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 打开文件</span><br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;f&#x27;</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-comment"># 打印异常堆栈</span><br>    print(e)<br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-comment"># 关闭文件</span><br>    f.close()<br></code></pre></td></tr></table></figure><p>当运行发生异常的时候，<code>finally</code> 块里的代码会确保资源被正常的关闭，以此来引发内存泄漏，或者是下面这种实现方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 打开文件</span><br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;f&#x27;</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-comment"># 打印异常堆栈</span><br>    print(e)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># 关闭文件</span><br>    f.close()<br></code></pre></td></tr></table></figure><p>当资源被正确打开时，没发生异常的情况下，代码最终回到 <code>else</code>块，而资源会被正确的关闭。由此可见这样的代码是写的非常长的，同时对资源的管理，异常的捕捉又不是十分方便，这个时候 <code>with</code> 语句就派上用场了。</p><p>使用<code>with</code> 语句，可以优雅的实现资源的关闭，如下代码所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;some.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    print(f.read())<br>print(f.closed)<br><span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><p>在<code>with</code> 语句中使用 <code>open</code>函数时，完全不必担心打开的文件会没关闭，因为离开<code>with</code>语句块之后，此时打印<code>f.closed</code>已经可以看到为<code>True</code>，为何 <code>open</code> 函数能在 <code>with</code>语句里面做到自动关闭文件的操作，因为它内部实现了 <code>__enter__()</code> 和 <code>__exit__()</code>方法。</p><h2 id="三、实现自定义上下文管理器"><a href="#三、实现自定义上下文管理器" class="headerlink" title="三、实现自定义上下文管理器"></a>三、实现自定义上下文管理器</h2><p>实现自定义上下文的前提是，要在自定义类里面实现 <code>__enter__()</code> 方法和 <code>__exit__()</code> 方法。</p><ul><li><code>__enter__()</code>：当<code>with</code>语句块运行后， 会在上下文管理器对象里执行<code>__enter__()</code> 方法，通常情况下，这个方法应该返回一个赋值给 <code>as</code> 后变量的对象，默认情况下为 <code>None</code>，同时这个是可选的，如果不需要返回，那么同时也不需要使用 <code>as</code> 语句。标准上来说应该返回<code>self</code>。</li><li><code>__exit__()</code>：当<code>with</code> 语句结束后，上下文管理器会调用<code>__exit__()</code>方法，效果等同于<code>finally</code>关键字。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">File</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, mode, filename</span>):</span><br>        self.filename = filename<br>        self.mode = mode<br>        self.file = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;__enter__&quot;</span>)<br>        self.file = <span class="hljs-built_in">open</span>(self.filename, self.mode)<br>        <span class="hljs-keyword">return</span> self.file<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span>(<span class="hljs-params">self, exec_type, exec_val, exec_tb</span>):</span><br>        print(<span class="hljs-string">&quot;__exit__&quot;</span>)<br>        <span class="hljs-keyword">if</span> self.file <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self.file.close()<br>        <br><br><span class="hljs-keyword">with</span> File(<span class="hljs-string">&#x27;some.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    data = f.read()<br>    print(data)<br><br>print(f.closed)<br><span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><p>当程序进入 <code>with</code> 语句块之后，<code>__exit__()</code> 方法会帮我们处理好异常，但是 <code>__exit__()</code>语句需要接受4个参数，第一个是 <code>self</code>，其他三个参数分别是异常类型，异常属性，异常跟踪信息。</p><h2 id="四、使用装饰器实现上下文管理器"><a href="#四、使用装饰器实现上下文管理器" class="headerlink" title="四、使用装饰器实现上下文管理器"></a>四、使用装饰器实现上下文管理器</h2><p>如果只是为了创建一个上下文管理器而创建一个类的话，未免也太麻烦了，这个时候 <code>contextlib </code>  的  <code>contextmanager</code> 装饰器就起到了作用，使用这个装饰器可以轻松的在函数上实现上下文管理器，同时它采用的是生成器的实现方式； 以下是代码示范。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager<br><br><br><span class="hljs-meta">@contextmanager</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">file</span>(<span class="hljs-params">filename, mode</span>):</span><br>    f = <span class="hljs-built_in">open</span>(filename, mode)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">yield</span> f<br>     <span class="hljs-keyword">finally</span>:<br>file.close()<br><br><span class="hljs-keyword">with</span> file(<span class="hljs-string">&#x27;some.text&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    data = f.read()<br>    print(data)<br><br>print(f.closed)<br><span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><h2 id="五、异步上下文装饰器"><a href="#五、异步上下文装饰器" class="headerlink" title="五、异步上下文装饰器"></a>五、异步上下文装饰器</h2><p> 前面的都是基于同步的上下文管理器，<code>contextlib</code> 里还提供了异步的上下文管理器，使用 <code>asynccontextmanager</code> 实现，同样的，这个方法需要放在异步的方法上，才会起作用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> asynccontextmanager<br><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-meta">@asynccontextmanager    </span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">web_crawler</span>(<span class="hljs-params">url</span>):</span>    <br>    data = <span class="hljs-keyword">await</span> get_page(url)  <br>    <span class="hljs-keyword">yield</span> data  <span class="hljs-comment"># 4</span><br>    <span class="hljs-keyword">await</span> save_content(url)    <br> <br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> web_crawler(<span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>) <span class="hljs-keyword">as</span> data:  <br>    print(data)<br><br>asyncio.run(web_crawler())<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>上下文</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入Flask配置</title>
    <link href="/2020/0710/46196.html"/>
    <url>/2020/0710/46196.html</url>
    
    <content type="html"><![CDATA[<h1 id="深入Flask配置"><a href="#深入Flask配置" class="headerlink" title="深入Flask配置"></a>深入Flask配置</h1><p>在Flask中，提供了丰富的全局配置来方便开发，以下是开发过程当中几个常用的配置选项。</p><table><thead><tr><th>配置名</th><th>作用</th></tr></thead><tbody><tr><td>DEBUG</td><td>启用/禁用调试模式</td></tr><tr><td>SECRET_KEY</td><td>密钥</td></tr><tr><td>SERVER_NAME</td><td>服务器名和端口。需要这个选项来支持子域名 （例如： <code>&#39;myapp.dev:5000&#39;</code> ）。注意 localhost 不支持子域名，所以把这个选项设置为 “localhost” 没有意义。设置 <code>SERVER_NAME</code> 默认会允许在没有请求上下文而仅有应用上下文时生成 URL</td></tr><tr><td>SESSION_COOKIE_NAME</td><td>会话 cookie 的名称。</td></tr></tbody></table><p>更多的配置详见<a href="http://docs.jinkan.org/docs/flask/config.html">官方文档</a>。</p><p>如果要在 <code>Flask</code> 中激活某些的配置，通常有以下8种方式，前面的两种都是针对某个单独配置。第三种方式，就是采用字典的更新键值对的方法，因为 <code>Config</code> 类本身就是继承自字典，所以同时也继承了字典的 <code>update</code> 方法。 而后面的几种方式，则可以对多个配置项进行处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">app.debug  = <span class="hljs-literal">True</span><br>app.config[<span class="hljs-string">&quot;debug&quot;</span>] = <span class="hljs-literal">True</span><br>app.config.update()<br>app.config.from_envvar()<br>app.config.from_json()<br>app.config.from_mapping()<br>app.config.from_pyfile()<br>app.config.from_object()<br></code></pre></td></tr></table></figure><p>下面谈谈其他几种方法的内部操作以及原理。</p><h2 id="一、Config-配置类的创建过程"><a href="#一、Config-配置类的创建过程" class="headerlink" title="一、Config 配置类的创建过程"></a>一、<code>Config</code> 配置类的创建过程</h2><p>首先 <code>Config</code> 类是在 <code>flask/config.py</code> 文件里面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 从这里可以看出 Config类 继承了 dict</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span>(<span class="hljs-params"><span class="hljs-built_in">dict</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, root_path, defaults=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">dict</span>.__init__(self, defaults <span class="hljs-keyword">or</span> &#123;&#125;)<br>        self.root_path = root_path<br></code></pre></td></tr></table></figure><p>下面是 <code>flask/app.py</code> 里面的 <code>Flask</code> 类，由于这个类的代码数量庞大，所以只贴出一点用到了 <code>Config</code> 类的地方。</p><p>可以看到 <code>default_config</code>  是一个 <code>ImmutableDict</code> <strong>（不可变字典对象）</strong>，里面是所有支持的配置项，并且都给出了默认值。</p><p>而 <code>Config</code> 类会被赋值给 <code>Flask</code> 的成员对象 <code>config_class</code>，但此时这个成员对象，也就是字典对象，还没有任何数据；所以要通过 <code>Flask</code> 的 <code>make_config</code> 来为 <code>config_class</code> 赋值字典数据，而此时传入的配置就是 <code>defaults</code>，包包含了  <code>Flask</code> 全部配置项。  初始时的两个配置项 <code>ENV</code> 和 <code>DEBUG</code> 会通过 <code>get_env()</code> 方法 和 <code>get_debug()</code> 方法设置为 <code>production</code> 和 <code>False</code>。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flask</span>(<span class="hljs-params">_PackageBoundObject</span>):</span><br>    <span class="hljs-comment"># 这里的 Config 类就是 flask/Config.py 下面的 Config 类</span><br>    config_class = Config<br>    <br>    <span class="hljs-comment"># 所有支持的配置项</span><br>    default_config = ImmutableDict(<br>        &#123;<br>            <span class="hljs-string">&quot;ENV&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;DEBUG&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;TESTING&quot;</span>: <span class="hljs-literal">False</span>,<br>            <span class="hljs-string">&quot;PROPAGATE_EXCEPTIONS&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;PRESERVE_CONTEXT_ON_EXCEPTION&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;SECRET_KEY&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;PERMANENT_SESSION_LIFETIME&quot;</span>: timedelta(days=<span class="hljs-number">31</span>),<br>            <span class="hljs-string">&quot;USE_X_SENDFILE&quot;</span>: <span class="hljs-literal">False</span>,<br>            <span class="hljs-string">&quot;SERVER_NAME&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;APPLICATION_ROOT&quot;</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>            <span class="hljs-string">&quot;SESSION_COOKIE_NAME&quot;</span>: <span class="hljs-string">&quot;session&quot;</span>,<br>            <span class="hljs-string">&quot;SESSION_COOKIE_DOMAIN&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;SESSION_COOKIE_PATH&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;SESSION_COOKIE_HTTPONLY&quot;</span>: <span class="hljs-literal">True</span>,<br>            <span class="hljs-string">&quot;SESSION_COOKIE_SECURE&quot;</span>: <span class="hljs-literal">False</span>,<br>            <span class="hljs-string">&quot;SESSION_COOKIE_SAMESITE&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;SESSION_REFRESH_EACH_REQUEST&quot;</span>: <span class="hljs-literal">True</span>,<br>            <span class="hljs-string">&quot;MAX_CONTENT_LENGTH&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;SEND_FILE_MAX_AGE_DEFAULT&quot;</span>: timedelta(hours=<span class="hljs-number">12</span>),<br>            <span class="hljs-string">&quot;TRAP_BAD_REQUEST_ERRORS&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;TRAP_HTTP_EXCEPTIONS&quot;</span>: <span class="hljs-literal">False</span>,<br>            <span class="hljs-string">&quot;EXPLAIN_TEMPLATE_LOADING&quot;</span>: <span class="hljs-literal">False</span>,<br>            <span class="hljs-string">&quot;PREFERRED_URL_SCHEME&quot;</span>: <span class="hljs-string">&quot;http&quot;</span>,<br>            <span class="hljs-string">&quot;JSON_AS_ASCII&quot;</span>: <span class="hljs-literal">True</span>,<br>            <span class="hljs-string">&quot;JSON_SORT_KEYS&quot;</span>: <span class="hljs-literal">True</span>,<br>            <span class="hljs-string">&quot;JSONIFY_PRETTYPRINT_REGULAR&quot;</span>: <span class="hljs-literal">False</span>,<br>            <span class="hljs-string">&quot;JSONIFY_MIMETYPE&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>,<br>            <span class="hljs-string">&quot;TEMPLATES_AUTO_RELOAD&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;MAX_COOKIE_SIZE&quot;</span>: <span class="hljs-number">4093</span>,<br>        &#125;<br>    )<br>    <br>    <span class="hljs-comment"># 返回初始完毕的配置类</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_config</span>(<span class="hljs-params">self, instance_relative=<span class="hljs-literal">False</span></span>):</span><br>        root_path = self.root_path<br>        <span class="hljs-keyword">if</span> instance_relative:<br>            root_path = self.instance_path<br>        defaults = <span class="hljs-built_in">dict</span>(self.default_config)<br>        defaults[<span class="hljs-string">&quot;ENV&quot;</span>] = get_env()<br>        defaults[<span class="hljs-string">&quot;DEBUG&quot;</span>] = get_debug_flag()<br>        <span class="hljs-keyword">return</span> self.config_class(root_path, defaults)<br></code></pre></td></tr></table></figure><h2 id="二、从环境变量中读取配置属性"><a href="#二、从环境变量中读取配置属性" class="headerlink" title="二、从环境变量中读取配置属性"></a>二、从环境变量中读取配置属性</h2><p>当在环境变量中设置了配置文件的环境变量，那么则可以使用这个方法。</p><p>首先是使用 <code>os</code> 模块的 <code>environ.get()</code> 方法来获取环境变量属性值，而后再调用另一个方法，这个环境变量的属性值是一个文件路径，通常的话，这个配置文件应该方法在和启动文件在同一个路径下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_envvar</span>(<span class="hljs-params">self, variable_name, silent=<span class="hljs-literal">False</span></span>):</span><br>        rv = os.environ.get(variable_name)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> rv:<br>            <span class="hljs-keyword">if</span> silent:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">raise</span> RuntimeError(<br>                <span class="hljs-string">&quot;The environment variable %r is not set &quot;</span><br>                <span class="hljs-string">&quot;and as such configuration could not be &quot;</span><br>                <span class="hljs-string">&quot;loaded.  Set this variable and make it &quot;</span><br>                <span class="hljs-string">&quot;point to a configuration file&quot;</span> % variable_name<br>            )<br>        <span class="hljs-keyword">return</span> self.from_pyfile(rv, silent=silent)<br></code></pre></td></tr></table></figure><p>在项目的同目录下创建一个 <code>config.cfg</code> 配置文件，写入两个简单的配置项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">DEBUG=True<br>SECRET_KEY=&quot;something&quot;<br></code></pre></td></tr></table></figure><p>使用os模块临时设置一个环境变量，当从环境变量中读取到配置文件后，在网页中能打印到配置属性的值。</p><p>还有一种办法是(针对 <code>Linux</code> 环境)，新开一个终端，切换到项目的目录下，在启动项目前，先使用 <code>export FLASK_CONFIG=config.cfg</code>，然后启动文件里面只需要写 <code>app.config.from_envvar(&quot;FLASK_CONFIG&quot;)</code>就可以，当然使用 <code>export</code> 设置的也只是一个临时变量，只对目前的终端有效。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br>app = Flask(__name__)<br><br>os.environ.setdefault(<span class="hljs-string">&quot;FLASK_CONFIG&quot;</span>, <span class="hljs-string">&quot;config.cfg&quot;</span>)<br><br>app.config.from_envvar(<span class="hljs-string">&quot;FLASK_CONFIG&quot;</span>)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DEBUG %s SECRET_KEY %s&quot;</span> % (app.config.get(<span class="hljs-string">&quot;DEBUG&quot;</span>), app.config.get(<span class="hljs-string">&quot;SECRET_KEY&quot;</span>))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app.run()<br></code></pre></td></tr></table></figure><p>我比较在意的是这个 <code>silent</code> 参数， 这个参数的含义是，当配置文件丢失时，或者环境变量没有设置时，设置 <code>silent</code> 参数为True，那么就等于没有配置这个文件。</p><p>那么可以写一个函数来检测这个配置文件是否存在，是否设置环境变量，当两个都没有时，返回 <code>True</code>，然后 <code>from_envvar</code> 方法将会不起作用，触发异常。</p><p>下面是一个简单的例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br><span class="hljs-keyword">import</span> os<br><br>app = Flask(__name__)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_set</span>():</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.environ.get(<span class="hljs-string">&quot;FLASK_CONFIG&quot;</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> os.path.exists(<span class="hljs-string">&quot;config.cfg&quot;</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>app.config.from_envvar(<span class="hljs-string">&quot;FLASK_CONFIG&quot;</span>, silent=is_set())<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span></span><br><span class="hljs-function">    <span class="hljs-title">return</span> &quot;<span class="hljs-title">DEBUG</span> %<span class="hljs-title">s</span> <span class="hljs-title">SECRET_KEY</span> %<span class="hljs-title">s</span>&quot; % (<span class="hljs-params">app.config.get(<span class="hljs-params"><span class="hljs-string">&quot;DEBUG&quot;</span></span>), app.config.get(<span class="hljs-params"><span class="hljs-string">&quot;SECRET_KEY&quot;</span></span>)</span>)</span><br><span class="hljs-function"></span><br>if __name__ == &quot;__main__&quot;:<br>    app.run()<br></code></pre></td></tr></table></figure><p>针对 <code>silent</code> 参数，写出一个方法来最终决定 <code>silent</code> 的值，这样防止了中间环境变量配置出错以及文件不存在等等情况。</p><h2 id="三、-从-python-文件中读取配置属性"><a href="#三、-从-python-文件中读取配置属性" class="headerlink" title="三、 从 python 文件中读取配置属性"></a>三、 从 <code>python</code> 文件中读取配置属性</h2><blockquote><p>  当创建一个 <code>Flask</code> 的实例对象之后，使用 <code>app.config.from_pyfile</code> 方法，传入一个配置文件字符串，从配置文件中读取属性并且写入，前面的 <code>from_envvar</code> 方法获取到配置文件后最终也会调用这个方法，并且，这个方法最终也会调用下一个方法 <code>from_object</code>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function">def <span class="hljs-title">from_pyfile</span><span class="hljs-params">(self, filename, silent=False)</span>:</span><br><span class="hljs-function">    filename </span>= os.path.join(self.root_path, filename)<br>        d = types.ModuleType(<span class="hljs-string">&quot;config&quot;</span>)<br>        d.__file__ = filename<br>    <span class="hljs-keyword">try</span>:<br>with open(filename, mode=<span class="hljs-string">&quot;rb&quot;</span>) as config_file:<br>exec(compile(config_file.read(), filename, <span class="hljs-string">&quot;exec&quot;</span>), d.__dict__)<br>    except IOError as e:<br><span class="hljs-keyword">if</span> silent <span class="hljs-keyword">and</span> e.errno in (errno.ENOENT, errno.EISDIR, errno.ENOTDIR):<br><span class="hljs-keyword">return</span> False<br>    e.strerror = <span class="hljs-string">&quot;Unable to load configuration file (%s)&quot;</span> % e.strerror<br>    raise<br>    self.from_object(d)<br>    <span class="hljs-keyword">return</span> True<br></code></pre></td></tr></table></figure><p>在项目的根目录下创建一个名为 <code>config.cfg</code> 简单配置文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">DEBUG=<span class="hljs-literal">True</span><br>SECRET_KEY=<span class="hljs-string">&quot;something&quot;</span><br></code></pre></td></tr></table></figure><p>先看 <code>from_pyfile</code> 文件前面的三段代码， 首先使用 <code>os</code>获取配置文件的绝对路径，然后用 <code>types.ModuleType</code> 方法动态创建了一个 <code>config</code> 模块，并且设置文件名为传进来的文件名的绝对路径文件名，此时这个 <code>config</code> 算是一个模块了，不是用普通的 <code>import</code> 方法导入的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">filename = os.path.join(self.root_path, filename)<br>d = types.ModuleType(<span class="hljs-string">&quot;config&quot;</span>)<br>d.__file__ = filename<br></code></pre></td></tr></table></figure><p><code>types</code> 属于 <code>Python</code>的标准库，里面的几个常用的方法没怎么了解，有如下几个。</p><ul><li>  <code>FunctionType</code>：通过不使用 <code>def</code> 的方式动态创建一个函数。</li><li>  <code>MethodType</code>：将创建在类外的某个方法动态绑定到类的实例上。</li><li>  <code>ModuleType</code>：动态的创建一个临时的模块。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> types<br><br><span class="hljs-comment"># 动态创建一个模块</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m = types.ModuleType(<span class="hljs-string">&quot;sample&quot;</span>, <span class="hljs-string">&quot;sample module.&quot;</span>)  <span class="hljs-comment"># 传入一个模块名，以及模块的文档字符串</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m<br>&lt;module <span class="hljs-string">&#x27;sample&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>m.__dict__<br>&#123;<span class="hljs-string">&#x27;__name__&#x27;</span>: <span class="hljs-string">&#x27;sample&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-string">&#x27;sample module.&#x27;</span>, <span class="hljs-string">&#x27;__package__&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;__loader__&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;__spec__&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>m <span class="hljs-keyword">in</span> sys.modules   <span class="hljs-comment"># 模块不包含在系统模块中</span><br><span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 动态添加类方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">pass</span><br><span class="hljs-meta">... </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>p = Person()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say</span>(<span class="hljs-params">self</span>):</span> print(<span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.say = types.MethodType(say, p)<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.say()<br>hello<br><br><span class="hljs-comment"># 动态创建一个函数</span><br>&gt;&gt; foo_code = <span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;def foo(): return &quot;bar&quot;&#x27;</span>, <span class="hljs-string">&quot;&lt;string&gt;&quot;</span>, <span class="hljs-string">&quot;exec&quot;</span>)<br>&gt;&gt; foo_func = types.FunctionType(foo_code.co_consts[<span class="hljs-number">0</span>], <span class="hljs-built_in">globals</span>(), <span class="hljs-string">&quot;foo&quot;</span>)<br>&gt;&gt; print(foo_func())<br>bar<br></code></pre></td></tr></table></figure><p>继续看 <code>from_pyfile</code> 方法剩下的代码，读取配置文件的配置属性，此时把属性放进动态创建的模块的字典里头，最后是调用另一个方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, mode=<span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> config_file:<br>exec(<span class="hljs-built_in">compile</span>(config_file.read(), filename, <span class="hljs-string">&quot;exec&quot;</span>), d.__dict__)<br><span class="hljs-keyword">except</span> IOError <span class="hljs-keyword">as</span> e:<br><span class="hljs-keyword">if</span> silent <span class="hljs-keyword">and</span> e.errno <span class="hljs-keyword">in</span> (errno.ENOENT, errno.EISDIR, errno.ENOTDIR):<br><span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    e.strerror = <span class="hljs-string">&quot;Unable to load configuration file (%s)&quot;</span> % e.strerror<br><span class="hljs-keyword">raise</span><br>self.from_object(d)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="四、从-python对象中提取属性"><a href="#四、从-python对象中提取属性" class="headerlink" title="四、从  python对象中提取属性"></a>四、从  <code>python</code>对象中提取属性</h2><p>从 <code>python</code> 对象中提取配置相对简单，一般写一个配置类的 <code>python</code> 文件，里面定义一个基类，设定一些基本配置，然后使用类继承的方法为各种环境设置扩展配置类，一个简单的配置类如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    DEBUG = <span class="hljs-literal">False</span><br>    TESTING = <span class="hljs-literal">False</span><br>    DATABASE_URI = <span class="hljs-string">&#x27;sqlite://:memory:&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductionConfig</span>(<span class="hljs-params">Config</span>):</span><br>    DATABASE_URI = <span class="hljs-string">&#x27;mysql://user@localhost/foo&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DevelopmentConfig</span>(<span class="hljs-params">Config</span>):</span><br>    DEBUG = <span class="hljs-literal">True</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestingConfig</span>(<span class="hljs-params">Config</span>):</span><br>    TESTING = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>之后就是在 <code>from_object</code> 方法里传入一个类名，或者一个完整的模块字符串就可以配置好配置属性。如果传入的是一个配置类，那么 <code>   if isinstance(obj, string_types)</code> 直接为 <code>False</code>，然后这个传入的配置类的所有属性，如果包含大写的属性，将存入 <code>app.config</code> 的字典中。如果是字符串，那么会先把模块里面的类导入再提取属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_object</span>(<span class="hljs-params">self, obj</span>):</span><br>   <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(obj, string_types):<br>            obj = import_string(obj)<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> <span class="hljs-built_in">dir</span>(obj):<br>        <span class="hljs-keyword">if</span> key.isupper():<br>            self[key] = <span class="hljs-built_in">getattr</span>(obj, key)<br></code></pre></td></tr></table></figure><p><code>string_types</code> ，这个变量在  <code>flask</code> 包的  <code>_compat.py</code>  下，其实就是<code>string</code> 类型，所以简单对传进来的参数检查是不是个字符串，如果是字符串，则会调用 <code>import_string</code> 方法，如果不是字符串而是一个具体的类则直接执行 <code>for</code> 循环对类的属性遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:  <span class="hljs-comment"># Python 2</span><br>    text_type = unicode<br>    string_types = (<span class="hljs-built_in">str</span>, unicode)<br>    integer_types = (<span class="hljs-built_in">int</span>, long)<br><span class="hljs-keyword">except</span> NameError:  <span class="hljs-comment"># Python 3</span><br>    text_type = <span class="hljs-built_in">str</span><br>    string_types = (<span class="hljs-built_in">str</span>,)<br>    integer_types = (<span class="hljs-built_in">int</span>,)<br></code></pre></td></tr></table></figure><p>然后是  <code>import_string</code> 方法，因为传进来的仅仅是个字符串，还没对模块进行导入，所以会用到 <code>werkzeug.utils</code> 包下的 <code>import_string</code> 方法对模块进行导入。</p><p>可以看到 <code>import_string</code>  的第一行代码会对字符串进行替换，那说明有两种写法，而恰恰函数文档也说明了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">提供两种模块写法：例如</span><br><span class="hljs-string">xml.sax.saxutils.escape</span><br><span class="hljs-string">xml.sax.saxutils:escape</span><br><span class="hljs-string">无论是那种写法，最后都会变成下面这种写法</span><br><span class="hljs-string">xml.sax.saxutils.escape</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>import_name = <span class="hljs-built_in">str</span>(import_name).replace(<span class="hljs-string">&quot;:&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>)<br></code></pre></td></tr></table></figure><p>接下来就是使用不寻常的导包方式，一般导包都是两种方式，<code>import package</code>或者是 <code>from package import module</code>，因为我们这里传进来的是字符串，所以不能用正常的导包方式，只能使用 <code>__import__</code> 这个内建方法，实际上 <code>import</code> 也是调用 <code>__import__</code>。假设配置类 <code>BaseConfig</code> 在 <code>Config</code>  包下的 <code>Settings.py</code> 模块下，那么可以写为 <code>Config.Settings:BaseConfig</code>，或者 <code>Config.Settings.BaseConfig</code> ，两者的可以。最终，如果导入为空时，那么会从 <code>sys.modules</code> 里面查询这个包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">__import__</span>(import_name)<br><span class="hljs-keyword">except</span> ImportError:<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> import_name:<br>        <span class="hljs-keyword">raise</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> sys.modules[import_name]<br></code></pre></td></tr></table></figure><p>如果这个传入的配置类字符串为 <code>Config.Settings.BaseConfig</code>，那么先把模块名和对象名分开，再尝试使用 <code>__import__</code> 方法导入，此时已经把模块名和对象名分开了，分别把模块名和对象名传入 <code>__import__</code> 就可以正常导入。再使用 <code>getattr</code> 方法获取模块里面的对象，这个方法告一段落。最后就是把返回的对象遍历获取里面的配置属性添加到 <code>Config</code> 对象中。</p><p><code>__import_</code> 的四个参数：</p><ul><li>  <code>name (required)</code>: 被加载 <code>module</code> 的名称</li><li>  <code>globals (optional)</code> : 包含全局变量的字典，该选项很少使用，采用默认值 <code>global()</code></li><li>  <code>locals (optional)</code>:  包含局部变量的字典，内部标准实现未用到该变量，采用默认值 <code>local()</code></li><li>  <code>fromlist (Optional)</code> : 被导入的子模块名称</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">module_name, obj_name = import_name.rsplit(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-number">1</span>)<br>module = <span class="hljs-built_in">__import__</span>(module_name, <span class="hljs-built_in">globals</span>(), <span class="hljs-built_in">locals</span>(), [obj_name])<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(module, obj_name)<br><span class="hljs-keyword">except</span> AttributeError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-keyword">raise</span> ImportError(e)<br></code></pre></td></tr></table></figure><p>总的来说这个方法提供了两种导入配置的选择，一种是传入模块字符串，一种是直接传入配置类。便于导入的时候选择导入方式和可扩展性。</p><h2 id="五、从-json-文件中读取配置属性到映射为字典"><a href="#五、从-json-文件中读取配置属性到映射为字典" class="headerlink" title="五、从 json 文件中读取配置属性到映射为字典"></a>五、从 <code>json</code> 文件中读取配置属性到映射为字典</h2><p>这个方法最终也会调用 <code>Config</code> 类的最后一个方法，对于这个方法而言，只是简单的读取一下 <code>json</code> 文件，并且把 <code>json</code> 文件里面的数据转化为 <code>Python</code> 当中的字典类型。同时可以设置 <code>silent</code> 为 <code>True</code>，当文件读取失败的时候，方法直接失效，如果不设置为 <code>True</code> 的话，也可以，直接触发标准错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_json</span>(<span class="hljs-params">self, filename, silent=<span class="hljs-literal">False</span></span>):</span><br>    filename = os.path.join(self.root_path, filename)<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> json_file:<br>            obj = json.loads(json_file.read())<br><span class="hljs-keyword">except</span> IOError <span class="hljs-keyword">as</span> e:<br><span class="hljs-keyword">if</span> silent <span class="hljs-keyword">and</span> e.errno <span class="hljs-keyword">in</span> (errno.ENOENT, errno.EISDIR):<br><span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>e.strerror = <span class="hljs-string">&quot;Unable to load configuration file (%s)&quot;</span> % e.strerror<br><span class="hljs-keyword">raise</span><br><span class="hljs-keyword">return</span> self.from_mapping(obj)<br></code></pre></td></tr></table></figure><p>在项目的根目录下创建一个名为 <code>config.json</code> 的配置文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">&#123;<br>    <span class="hljs-string">&quot;DEBUG&quot;</span>: <span class="hljs-string">&quot;True&quot;</span>,<br>    <span class="hljs-string">&quot;SECRET_KEY&quot;</span>: <span class="hljs-string">&quot;something&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>示例代码，当程序启动时，打开 <code>http://127.0.0.1:5000/</code> 就可以看到 <code>DEBUG</code> 和 <code>SECRET_KEY </code> 的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br><br>app = Flask(__name__)<br><br>app.config.from_json(<span class="hljs-string">&quot;config.json&quot;</span>)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DEBUG %s SECRET_KEY %s&quot;</span> % (app.config.get(<span class="hljs-string">&quot;DEBUG&quot;</span>), app.config.get(<span class="hljs-string">&quot;SECRET_KEY&quot;</span>))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app.run()<br>    print(app.config.items())<br></code></pre></td></tr></table></figure><h2 id="六、从-python-键值对-dict-中配置属性"><a href="#六、从-python-键值对-dict-中配置属性" class="headerlink" title="六、从 python 键值对 ( dict ) 中配置属性"></a>六、从 <code>python</code> 键值对 <code>( dict )</code> 中配置属性</h2><p>设置一个简单的字典对象，待会传入 <code>from_mappings</code> 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">configs = &#123;<br>    <span class="hljs-string">&quot;DEBUG&quot;</span>: <span class="hljs-literal">True</span>,<br>    <span class="hljs-string">&quot;SECRET_KEY&quot;</span>: <span class="hljs-string">&quot;Something&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后一个方法，针对传进来的键值对，也就是字典，这里对应第三个参数 <code>**kwargs</code>，使用 <code>kwargs.items()</code> 提取出所有的键值对( 列表格式 ) 存放进 <code>mappings</code> 列表里，然后再通过二层循环提取出每个配置的键和值，存放进 <code>Config</code> 类的里面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_mapping</span>(<span class="hljs-params">self, *mapping, **kwargs</span>):</span><br>    <br>        mappings = []<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(mapping) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(mapping[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;items&quot;</span>):<br>                mappings.append(mapping[<span class="hljs-number">0</span>].items())<br>            <span class="hljs-keyword">else</span>:<br>                mappings.append(mapping[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(mapping) &gt; <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">raise</span> TypeError(<br>                <span class="hljs-string">&quot;expected at most 1 positional argument, got %d&quot;</span> % <span class="hljs-built_in">len</span>(mapping)<br>            )<br>        mappings.append(kwargs.items())<br>        <span class="hljs-keyword">for</span> mapping <span class="hljs-keyword">in</span> mappings:<br>            <span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> mapping:<br>                <span class="hljs-keyword">if</span> key.isupper():<br>                    self[key] = value<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>例子示范，当启动程序时，在浏览器进入 <code>http://127.0.0.1:5000/</code> 就能看到 <code>DEBUG</code> 和 <code>SECRET_KEY</code> 的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br><br>app = Flask(__name__)<br><br>configs = &#123;<br>    <span class="hljs-string">&quot;DEBUG&quot;</span>: <span class="hljs-literal">True</span>,<br>    <span class="hljs-string">&quot;SECRET_KEY&quot;</span>: <span class="hljs-string">&quot;Something&quot;</span><br>&#125;<br><br>app.config.from_mappings(configs)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DEBUG %s SECRET_KEY %s&quot;</span> % (app.config.get(<span class="hljs-string">&quot;DEBUG&quot;</span>), app.config.get(<span class="hljs-string">&quot;SECRET_KEY&quot;</span>))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app.run()<br>    print(app.config.items())<br></code></pre></td></tr></table></figure><p>然后这个方法还提供另一种细化的使用，上面只是传入了第三个参数，第二个参数还没使用，显然这个函数是会使用到第二参数，那么这个参数格式有几种写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">mapping = (<br>    &#123;<br>        <span class="hljs-string">&quot;DEBUG&quot;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&quot;SECRET_KEY&quot;</span>: <span class="hljs-string">&quot;Something&quot;</span><br>    &#125;<br>)<br><span class="hljs-comment"># 直接执行 mappings.append(mapping[0])</span><br><br>mapping = (<br>    (<span class="hljs-string">&#x27;DEBUG&#x27;</span>, <span class="hljs-literal">True</span>),<br>    (<span class="hljs-string">&#x27;TESTING&#x27;</span>, <span class="hljs-literal">False</span>)<br>)<br><span class="hljs-comment"># 传入元祖，直接执行 mappings.append(mapping[0])</span><br></code></pre></td></tr></table></figure><p>此时就不需要传入第三个参数，也就是说这个方法提供两种参数传入方式，也方便扩展，如果单纯使用键值对，那么前面的代码将不会被执行，如果使用 <code>tuple</code> ，也会对这个参数进行操作，提取里面的属性值。</p><h2 id="七、自定义读取-yaml-properties配置文件"><a href="#七、自定义读取-yaml-properties配置文件" class="headerlink" title="七、自定义读取 yaml/properties配置文件"></a>七、自定义读取 yaml/properties配置文件</h2><blockquote><p>  上面提到可以用 <code>types.MethodType</code> 来创建动态方法，这里就可以利用这个来为 <code>config</code> 扩展读取更多类型的配置文件。</p></blockquote><p>示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> types<br><br><span class="hljs-comment"># 创建一个 Person 类，此时类里还没有任何方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say</span>(<span class="hljs-params">self, name</span>):</span><br>    self.name = name<br>    print(<span class="hljs-string">&quot;hello&quot;</span>, name)<br>    <br>p = Person()<br><br><span class="hljs-comment"># 强行把方法赋值到实例对象上</span><br>p.say = say<br><br>p.say(name=<span class="hljs-string">&quot;nick&quot;</span>) <br><span class="hljs-comment"># 报错</span><br><span class="hljs-comment"># say() missing 1 required positional argument: &#x27;self&#x27;</span><br><br><span class="hljs-comment"># 把 say 方法绑定到 Person 类的实例上</span><br>p.say = types.MethodType(say, p)<br><br>p.say(name=<span class="hljs-string">&quot;nick&quot;</span>)<br><br><span class="hljs-comment"># result: hello nick</span><br></code></pre></td></tr></table></figure><p>创建一个名为 <code>config.yaml</code> 的配置文件，写入两个简单的配置项。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">DEBUG:</span> <span class="hljs-literal">True</span><br><span class="hljs-attr">SECRET_KEY:</span> <span class="hljs-string">something</span><br></code></pre></td></tr></table></figure><p>读取 <code>yaml</code> 文件，编写读取 <code>yaml</code> 文件方法，利用了 <code>pyyaml</code> 库，使用  <code>yaml</code> 读取出来的数据是字典格式，然后传递给  <code>Config</code> 对象的        <code>from_mapping</code> 方法，然后利用 <code>types.MethodType</code> 方法为 <code>Config</code> 类动态添加方法，绑定在 <code>config</code> 对象上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br><span class="hljs-keyword">import</span> types<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> yaml<br><br><br>app = Flask(__name__)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_yaml</span>(<span class="hljs-params">self, filename, silent=<span class="hljs-literal">False</span></span>):</span><br>    filename = os.path.join(self.root_path, filename)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> yaml_file:<br>            obj = yaml.load(yaml_file.read(), Loader=yaml.FullLoader)<br>    <span class="hljs-keyword">except</span> IOError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">if</span> silent:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> self.from_mapping(obj)<br><br><span class="hljs-comment"># MethodType 方法第一个参数是需要动态添加的方法名，第二个参数是类的实例对象。</span><br>app.config.from_yaml = types.MethodType(from_yaml, app.config)<br>app.config.from_yaml(<span class="hljs-string">&quot;config.yaml&quot;</span>)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DEBUG %s SECRET_KEY %s&quot;</span> % (app.config.get(<span class="hljs-string">&quot;DEBUG&quot;</span>), app.config.get(<span class="hljs-string">&quot;SECRET_KEY&quot;</span>))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app.run()<br>    print(app.config.items())<br></code></pre></td></tr></table></figure><p>创建一个名为 <code>config.properties</code> 的简单配置文件，写入以下简单配置项。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">DEBUG</span>=<span class="hljs-string">True</span><br><span class="hljs-attr">SECRET_KEY</span>=<span class="hljs-string">something</span><br></code></pre></td></tr></table></figure><p>创建一个读取 <code>from_properties</code> 方法， 这个方法遍历  <code>properties</code> 文件的每一行，把  <code>=</code>  两边的属性名和属性值放进 <code>obj</code> 中，最终会调用现有的 <code>from_mapping</code> 方法，最后还是要利用 <code>types.MethodType</code> 方法为 <code>Config</code> 类动态添加方法，绑定在 <code>config</code> 对象上，这样这个方法才会起作用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">app = Flask(__name__)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_properties</span>(<span class="hljs-params">self, filename, silent=<span class="hljs-literal">False</span>, encode=<span class="hljs-literal">None</span></span>):</span><br>    filename = os.path.join(self.root_path, filename)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> properties_file:<br>            obj = &#123;&#125;<br>            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> properties_file:<br>                <span class="hljs-keyword">if</span> line.find(<span class="hljs-string">&#x27;=&#x27;</span>) &gt; <span class="hljs-number">0</span>:<br>                    s = line.replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).split(<span class="hljs-string">&quot;=&quot;</span>)<br>                    obj[s[<span class="hljs-number">0</span>]] = s[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">except</span> IOError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">if</span> silent:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> self.from_mapping(obj)<br><br>app.config.from_properties = types.MethodType(from_properties, app.config)<br><br>app.config.from_properties(<span class="hljs-string">&quot;config.properties&quot;</span>)<br><br><br></code></pre></td></tr></table></figure><p>当然，这两个方法可能也有不完善的地方，例如，<code>yaml</code> 文件可能是多层级的，这里只考虑到一层级，什么时候下才会出现多层级的配置项，例如，可以在一个 <code>yaml</code> 文件里面设置多个环境配置，开发环境配置，生产环境配置，部署环境配置等。</p><ul><li>  [ ] <code>yaml</code> 方法修改。</li><li>  [ ] 实例代码上传至 <code>github</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>源码阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Flask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux与Android剪切板同步方案</title>
    <link href="/2020/0516/12368.html"/>
    <url>/2020/0516/12368.html</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-与-Android-剪切板同步方案"><a href="#Linux-与-Android-剪切板同步方案" class="headerlink" title="Linux 与 Android 剪切板同步方案"></a><code>Linux</code> 与 <code>Android</code> 剪切板同步方案</h1><p>在 <code>Linux</code> 传输文件，图片，或是发送文字，都不如 <code>Windows</code> 那样方便，在 <code>Windows</code>  可以通过 <code>QQ</code> 里面发送文件，图片，或是文字等等。虽然说在<code>Linux</code>上可以通过其他方式来解决传文件的文件，例如：</p><span id="more"></span><ul><li><p>  <code>telegram</code></p></li><li><p>  微信网页版( 在2017年9月份开始，腾讯已经 开始限制 新注册的微信号禁止登录网页版微信，老的微信号则不受影响 ，并且网页版发送的文件大小不能超过 <code>90MB</code></p></li><li><p>  <code>python -m http.server 80</code>，但是不能复制文本，而且有些文件需要另存为下载。</p></li><li><p>  以及其他方法。。。</p></li></ul><p>现在找到 一种办法，电脑上使用 <code>GSConnect</code>，而安卓软件选择使用 <code>KDE Connect</code>。</p><p><code>GSConnect</code> 官方介绍：</p><blockquote><p>  <code>GSConnect</code> 是针对 <code>GNOME Shell</code> 的 <code>KDE Connect</code> 的完整实现，集成了 <code>Nautilus</code> 、<code>Chrome</code> 和 <code>Firefox</code>。</p><p>  将你的 PC 和 Android 设备与安装的 KDE Connect 应用配对: 传输文件，发送和接收短信文本，同步剪贴板和通知，发送鼠标和键盘输入，远程控制媒体播放器，定位你的设备，监视电池电量，在你的 PC 上启动命令，等等。</p></blockquote><p><code>GSConnect</code> 官方 <code>WIKI</code>：<a href="https://github.com/andyholmes/gnome-shell-extension-gsconnect/wiki/Installation#install-from-git">https://github.com/andyholmes/gnome-shell-extension-gsconnect/wiki/Installation#install-from-git</a></p><p><code>KDE Connect</code>可以在 <code>Google Play</code> 下载。</p><h2 id="1-安装方式"><a href="#1-安装方式" class="headerlink" title="1. 安装方式"></a>1. 安装方式</h2><p><code>GSConnect</code> 提供了两种安装方式，一种是通过从官方仓库的 <code>release</code> 页面下载最后一个版本的压缩包安装，另一种方式就是克隆官方仓库进行编译。</p><p>第一种方式的方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p ~/.local/share/gnome-shell/extensions<br>rm -rf ~/.local/share/gnome-shell/extensions/gsconnect@andyholmes.github.io<br>unzip -o gsconnect@andyholmes.github.io.zip -d ~/.local/share/gnome-shell/extensions/gsconnect@andyholmes.github.io<br></code></pre></td></tr></table></figure><p>第二种方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/andyholmes/gnome-shell-extension-gsconnect.git<br>cd gnome-shell-extension-gsconnect/<br>meson _build .<br>ninja -C _build install-zip<br></code></pre></td></tr></table></figure><p>选择第一种方式更方便，不需要编译，我选择的是第一种方式。</p><p>使用第二种安装方式的时候，编译出现了点问题，缺少两个构建工具：meson， ninja。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo aptitude install meson<br></code></pre></td></tr></table></figure><p>同时会安装 meson和ninja。</p><p>开始，构建，报错。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">The Meson build system<br>Version: 0.45.1<br>Source dir: /home/aim/SoftWare/gnome-shell-extension-gsconnect<br>Build dir: /home/aim/SoftWare/gnome-shell-extension-gsconnect/_build<br>Build type: native build<br><br>meson.build:1:0: ERROR: Meson version is 0.45.1 but project requires &gt;= 0.49.0.<br><br>A full log can be found at /home/aim/SoftWare/gnome-shell-extension-gsconnect/_build/meson-logs/meson-log.txt<br></code></pre></td></tr></table></figure><p>原来是meson版本低于依赖的版本。安装高版本的meson</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install meson==0.49.0<br></code></pre></td></tr></table></figure><h2 id="2-开始使用"><a href="#2-开始使用" class="headerlink" title="2. 开始使用"></a>2. 开始使用</h2><p>手机要和电脑处在同一个局域网，不然搜索不到。</p><p>手机打开 <code>Kde Connect</code>，点击 <code>⊕ Pair new device</code> 扫描周围设备进行配对，出现电脑名字的时候点击进行配对，电脑上点击<code>accept</code> 即可配对成功。</p><p>同时，为了方便的管理电脑上的剪切板剪切的文件，安装一个剪切板管理软件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo aptitude install copyq<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
