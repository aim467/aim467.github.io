<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浅谈上下文</title>
    <link href="/2021/0326/10778.html"/>
    <url>/2021/0326/10778.html</url>
    
    <content type="html"><![CDATA[<h1 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h1><p>写 <code> Python</code> 也好久了，在编写代码时，通常会用到一个表达式，<code>with .... as .....</code>，其中用的最多的可能是打开文件的时候使用这个表达式，但是却没想过为什么要这样写，或者这样写有什么方便之处，今天就来复习一下。</p><h2 id="一、上下文管理器"><a href="#一、上下文管理器" class="headerlink" title="一、上下文管理器"></a>一、上下文管理器</h2><p>何为上下文，在自然语言中，给你一段话，如果没有在上文和下文的情况下，你无法判断这段话在讲什么，也看不懂；这在计算机里也是如此，当一个程序独立存在的时候，它不依赖任何外部的数据或变量，此时它就不存在上下文，但是当多个程序关联起来，互相引用各自的数据或变量时，那么每个程序都不能独自运行了，这个时候就需要一个上下文，来管理这些各自的外部数据和变量。</p><p>而在 <code>Python</code> 中，则有了一个上下文管理器的概念，是指实现了 <code>__enter__()</code> 方法和 <code>__exit__()</code>方法的对象；同时上下文管理器的存在也是为了管理 <code>with</code> 语句。</p><h2 id="二、with-表达式的使用"><a href="#二、with-表达式的使用" class="headerlink" title="二、with 表达式的使用"></a>二、<code>with</code> 表达式的使用</h2><p>在 <code>with</code> 表达式出现之前，对于资源的管理通常使用三段式的方式来实现，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 打开文件</span><br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;f&#x27;</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-comment"># 打印异常堆栈</span><br>    print(e)<br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-comment"># 关闭文件</span><br>    f.close()<br></code></pre></div></td></tr></table></figure><p>当运行发生异常的时候，<code>finally</code> 块里的代码会确保资源被正常的关闭，以此来引发内存泄漏，或者是下面这种实现方式：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 打开文件</span><br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;f&#x27;</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-comment"># 打印异常堆栈</span><br>    print(e)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># 关闭文件</span><br>    f.close()<br></code></pre></div></td></tr></table></figure><p>当资源被正确打开时，没发生异常的情况下，代码最终回到 <code>else</code>块，而资源会被正确的关闭。由此可见这样的代码是写的非常长的，同时对资源的管理，异常的捕捉又不是十分方便，这个时候 <code>with</code> 语句就派上用场了。</p><p>使用<code>with</code> 语句，可以优雅的实现资源的关闭，如下代码所示。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;some.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    print(f.read())<br>print(f.closed)<br><span class="hljs-comment"># True</span><br></code></pre></div></td></tr></table></figure><p>在<code>with</code> 语句中使用 <code>open</code>函数时，完全不必担心打开的文件会没关闭，因为离开<code>with</code>语句块之后，此时打印<code>f.closed</code>已经可以看到为<code>True</code>，为何 <code>open</code> 函数能在 <code>with</code>语句里面做到自动关闭文件的操作，因为它内部实现了 <code>__enter__()</code> 和 <code>__exit__()</code>方法。</p><h2 id="三、实现自定义上下文管理器"><a href="#三、实现自定义上下文管理器" class="headerlink" title="三、实现自定义上下文管理器"></a>三、实现自定义上下文管理器</h2><p>实现自定义上下文的前提是，要在自定义类里面实现 <code>__enter__()</code> 方法和 <code>__exit__()</code> 方法。</p><ul><li><code>__enter__()</code>：当<code>with</code>语句块运行后， 会在上下文管理器对象里执行<code>__enter__()</code> 方法，通常情况下，这个方法应该返回一个赋值给 <code>as</code> 后变量的对象，默认情况下为 <code>None</code>，同时这个是可选的，如果不需要返回，那么同时也不需要使用 <code>as</code> 语句。标准上来说应该返回<code>self</code>。</li><li><code>__exit__()</code>：当<code>with</code> 语句结束后，上下文管理器会调用<code>__exit__()</code>方法，效果等同于<code>finally</code>关键字。</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">File</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, mode, filename</span>):</span><br>        self.filename = filename<br>        self.mode = mode<br>        self.file = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;__enter__&quot;</span>)<br>        self.file = <span class="hljs-built_in">open</span>(self.filename, self.mode)<br>        <span class="hljs-keyword">return</span> self.file<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span>(<span class="hljs-params">self, exec_type, exec_val, exec_tb</span>):</span><br>        print(<span class="hljs-string">&quot;__exit__&quot;</span>)<br>        <span class="hljs-keyword">if</span> self.file <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self.file.close()<br>        <br><br><span class="hljs-keyword">with</span> File(<span class="hljs-string">&#x27;some.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    data = f.read()<br>    print(data)<br><br>print(f.closed)<br><span class="hljs-comment"># True</span><br></code></pre></div></td></tr></table></figure><p>当程序进入 <code>with</code> 语句块之后，<code>__exit__()</code> 方法会帮我们处理好异常，但是 <code>__exit__()</code>语句需要接受4个参数，第一个是 <code>self</code>，其他三个参数分别是异常类型，异常属性，异常跟踪信息。</p><h2 id="四、使用装饰器实现上下文管理器"><a href="#四、使用装饰器实现上下文管理器" class="headerlink" title="四、使用装饰器实现上下文管理器"></a>四、使用装饰器实现上下文管理器</h2><p>如果只是为了创建一个上下文管理器而创建一个类的话，未免也太麻烦了，这个时候 <code>contextlib </code>  的  <code>contextmanager</code> 装饰器就起到了作用，使用这个装饰器可以轻松的在函数上实现上下文管理器，同时它采用的是生成器的实现方式； 以下是代码示范。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager<br><br><br><span class="hljs-meta">@contextmanager</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">file</span>(<span class="hljs-params">filename, mode</span>):</span><br>    f = <span class="hljs-built_in">open</span>(filename, mode)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">yield</span> f<br>     <span class="hljs-keyword">finally</span>:<br>file.close()<br><br><span class="hljs-keyword">with</span> file(<span class="hljs-string">&#x27;some.text&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    data = f.read()<br>    print(data)<br><br>print(f.closed)<br><span class="hljs-comment"># True</span><br></code></pre></div></td></tr></table></figure><h2 id="五、异步上下文装饰器"><a href="#五、异步上下文装饰器" class="headerlink" title="五、异步上下文装饰器"></a>五、异步上下文装饰器</h2><p> 前面的都是基于同步的上下文管理器，<code>contextlib</code> 里还提供了异步的上下文管理器，使用 <code>asynccontextmanager</code> 实现，同样的，这个方法需要放在异步的方法上，才会起作用。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> asynccontextmanager<br><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-meta">@asynccontextmanager    </span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">web_crawler</span>(<span class="hljs-params">url</span>):</span>    <br>    data = <span class="hljs-keyword">await</span> get_page(url)  <br>    <span class="hljs-keyword">yield</span> data  <span class="hljs-comment"># 4</span><br>    <span class="hljs-keyword">await</span> save_content(url)    <br> <br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> web_crawler(<span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>) <span class="hljs-keyword">as</span> data:  <br>    print(data)<br><br>asyncio.run(web_crawler())<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>上下文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/1114/16107.html"/>
    <url>/2020/1114/16107.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo server<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo generate<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入Flask配置</title>
    <link href="/2020/0710/46196.html"/>
    <url>/2020/0710/46196.html</url>
    
    <content type="html"><![CDATA[<h1 id="深入Flask配置"><a href="#深入Flask配置" class="headerlink" title="深入Flask配置"></a>深入Flask配置</h1><p>在Flask中，提供了丰富的全局配置来方便开发，以下是开发过程当中几个常用的配置选项。</p><table><thead><tr><th>配置名</th><th>作用</th></tr></thead><tbody><tr><td>DEBUG</td><td>启用/禁用调试模式</td></tr><tr><td>SECRET_KEY</td><td>密钥</td></tr><tr><td>SERVER_NAME</td><td>服务器名和端口。需要这个选项来支持子域名 （例如： <code>&#39;myapp.dev:5000&#39;</code> ）。注意 localhost 不支持子域名，所以把这个选项设置为 “localhost” 没有意义。设置 <code>SERVER_NAME</code> 默认会允许在没有请求上下文而仅有应用上下文时生成 URL</td></tr><tr><td>SESSION_COOKIE_NAME</td><td>会话 cookie 的名称。</td></tr></tbody></table><p>更多的配置详见<a href="http://docs.jinkan.org/docs/flask/config.html">官方文档</a>。</p><p>如果要在 <code>Flask</code> 中激活某些的配置，通常有以下8种方式，前面的两种都是针对某个单独配置。第三种方式，就是采用字典的更新键值对的方法，因为 <code>Config</code> 类本身就是继承自字典，所以同时也继承了字典的 <code>update</code> 方法。 而后面的几种方式，则可以对多个配置项进行处理。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">app.debug  = <span class="hljs-literal">True</span><br>app.config[<span class="hljs-string">&quot;debug&quot;</span>] = <span class="hljs-literal">True</span><br>app.config.update()<br>app.config.from_envvar()<br>app.config.from_json()<br>app.config.from_mapping()<br>app.config.from_pyfile()<br>app.config.from_object()<br></code></pre></div></td></tr></table></figure><p>下面谈谈其他几种方法的内部操作以及原理。</p><h2 id="一、Config-配置类的创建过程"><a href="#一、Config-配置类的创建过程" class="headerlink" title="一、Config 配置类的创建过程"></a>一、<code>Config</code> 配置类的创建过程</h2><p>首先 <code>Config</code> 类是在 <code>flask/config.py</code> 文件里面。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 从这里可以看出 Config类 继承了 dict</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span>(<span class="hljs-params"><span class="hljs-built_in">dict</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, root_path, defaults=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">dict</span>.__init__(self, defaults <span class="hljs-keyword">or</span> &#123;&#125;)<br>        self.root_path = root_path<br></code></pre></div></td></tr></table></figure><p>下面是 <code>flask/app.py</code> 里面的 <code>Flask</code> 类，由于这个类的代码数量庞大，所以只贴出一点用到了 <code>Config</code> 类的地方。</p><p>可以看到 <code>default_config</code>  是一个 <code>ImmutableDict</code> <strong>（不可变字典对象）</strong>，里面是所有支持的配置项，并且都给出了默认值。</p><p>而 <code>Config</code> 类会被赋值给 <code>Flask</code> 的成员对象 <code>config_class</code>，但此时这个成员对象，也就是字典对象，还没有任何数据；所以要通过 <code>Flask</code> 的 <code>make_config</code> 来为 <code>config_class</code> 赋值字典数据，而此时传入的配置就是 <code>defaults</code>，包包含了  <code>Flask</code> 全部配置项。  初始时的两个配置项 <code>ENV</code> 和 <code>DEBUG</code> 会通过 <code>get_env()</code> 方法 和 <code>get_debug()</code> 方法设置为 <code>production</code> 和 <code>False</code>。 </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flask</span>(<span class="hljs-params">_PackageBoundObject</span>):</span><br>    <span class="hljs-comment"># 这里的 Config 类就是 flask/Config.py 下面的 Config 类</span><br>    config_class = Config<br>    <br>    <span class="hljs-comment"># 所有支持的配置项</span><br>    default_config = ImmutableDict(<br>        &#123;<br>            <span class="hljs-string">&quot;ENV&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;DEBUG&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;TESTING&quot;</span>: <span class="hljs-literal">False</span>,<br>            <span class="hljs-string">&quot;PROPAGATE_EXCEPTIONS&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;PRESERVE_CONTEXT_ON_EXCEPTION&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;SECRET_KEY&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;PERMANENT_SESSION_LIFETIME&quot;</span>: timedelta(days=<span class="hljs-number">31</span>),<br>            <span class="hljs-string">&quot;USE_X_SENDFILE&quot;</span>: <span class="hljs-literal">False</span>,<br>            <span class="hljs-string">&quot;SERVER_NAME&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;APPLICATION_ROOT&quot;</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>            <span class="hljs-string">&quot;SESSION_COOKIE_NAME&quot;</span>: <span class="hljs-string">&quot;session&quot;</span>,<br>            <span class="hljs-string">&quot;SESSION_COOKIE_DOMAIN&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;SESSION_COOKIE_PATH&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;SESSION_COOKIE_HTTPONLY&quot;</span>: <span class="hljs-literal">True</span>,<br>            <span class="hljs-string">&quot;SESSION_COOKIE_SECURE&quot;</span>: <span class="hljs-literal">False</span>,<br>            <span class="hljs-string">&quot;SESSION_COOKIE_SAMESITE&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;SESSION_REFRESH_EACH_REQUEST&quot;</span>: <span class="hljs-literal">True</span>,<br>            <span class="hljs-string">&quot;MAX_CONTENT_LENGTH&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;SEND_FILE_MAX_AGE_DEFAULT&quot;</span>: timedelta(hours=<span class="hljs-number">12</span>),<br>            <span class="hljs-string">&quot;TRAP_BAD_REQUEST_ERRORS&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;TRAP_HTTP_EXCEPTIONS&quot;</span>: <span class="hljs-literal">False</span>,<br>            <span class="hljs-string">&quot;EXPLAIN_TEMPLATE_LOADING&quot;</span>: <span class="hljs-literal">False</span>,<br>            <span class="hljs-string">&quot;PREFERRED_URL_SCHEME&quot;</span>: <span class="hljs-string">&quot;http&quot;</span>,<br>            <span class="hljs-string">&quot;JSON_AS_ASCII&quot;</span>: <span class="hljs-literal">True</span>,<br>            <span class="hljs-string">&quot;JSON_SORT_KEYS&quot;</span>: <span class="hljs-literal">True</span>,<br>            <span class="hljs-string">&quot;JSONIFY_PRETTYPRINT_REGULAR&quot;</span>: <span class="hljs-literal">False</span>,<br>            <span class="hljs-string">&quot;JSONIFY_MIMETYPE&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>,<br>            <span class="hljs-string">&quot;TEMPLATES_AUTO_RELOAD&quot;</span>: <span class="hljs-literal">None</span>,<br>            <span class="hljs-string">&quot;MAX_COOKIE_SIZE&quot;</span>: <span class="hljs-number">4093</span>,<br>        &#125;<br>    )<br>    <br>    <span class="hljs-comment"># 返回初始完毕的配置类</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_config</span>(<span class="hljs-params">self, instance_relative=<span class="hljs-literal">False</span></span>):</span><br>        root_path = self.root_path<br>        <span class="hljs-keyword">if</span> instance_relative:<br>            root_path = self.instance_path<br>        defaults = <span class="hljs-built_in">dict</span>(self.default_config)<br>        defaults[<span class="hljs-string">&quot;ENV&quot;</span>] = get_env()<br>        defaults[<span class="hljs-string">&quot;DEBUG&quot;</span>] = get_debug_flag()<br>        <span class="hljs-keyword">return</span> self.config_class(root_path, defaults)<br></code></pre></div></td></tr></table></figure><h2 id="二、从环境变量中读取配置属性"><a href="#二、从环境变量中读取配置属性" class="headerlink" title="二、从环境变量中读取配置属性"></a>二、从环境变量中读取配置属性</h2><p>当在环境变量中设置了配置文件的环境变量，那么则可以使用这个方法。</p><p>首先是使用 <code>os</code> 模块的 <code>environ.get()</code> 方法来获取环境变量属性值，而后再调用另一个方法，这个环境变量的属性值是一个文件路径，通常的话，这个配置文件应该方法在和启动文件在同一个路径下。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_envvar</span>(<span class="hljs-params">self, variable_name, silent=<span class="hljs-literal">False</span></span>):</span><br>        rv = os.environ.get(variable_name)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> rv:<br>            <span class="hljs-keyword">if</span> silent:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">raise</span> RuntimeError(<br>                <span class="hljs-string">&quot;The environment variable %r is not set &quot;</span><br>                <span class="hljs-string">&quot;and as such configuration could not be &quot;</span><br>                <span class="hljs-string">&quot;loaded.  Set this variable and make it &quot;</span><br>                <span class="hljs-string">&quot;point to a configuration file&quot;</span> % variable_name<br>            )<br>        <span class="hljs-keyword">return</span> self.from_pyfile(rv, silent=silent)<br></code></pre></div></td></tr></table></figure><p>在项目的同目录下创建一个 <code>config.cfg</code> 配置文件，写入两个简单的配置项。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">DEBUG=True<br>SECRET_KEY=&quot;something&quot;<br></code></pre></div></td></tr></table></figure><p>使用os模块临时设置一个环境变量，当从环境变量中读取到配置文件后，在网页中能打印到配置属性的值。</p><p>还有一种办法是(针对 <code>Linux</code> 环境)，新开一个终端，切换到项目的目录下，在启动项目前，先使用 <code>export FLASK_CONFIG=config.cfg</code>，然后启动文件里面只需要写 <code>app.config.from_envvar(&quot;FLASK_CONFIG&quot;)</code>就可以，当然使用 <code>export</code> 设置的也只是一个临时变量，只对目前的终端有效。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br>app = Flask(__name__)<br><br>os.environ.setdefault(<span class="hljs-string">&quot;FLASK_CONFIG&quot;</span>, <span class="hljs-string">&quot;config.cfg&quot;</span>)<br><br>app.config.from_envvar(<span class="hljs-string">&quot;FLASK_CONFIG&quot;</span>)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DEBUG %s SECRET_KEY %s&quot;</span> % (app.config.get(<span class="hljs-string">&quot;DEBUG&quot;</span>), app.config.get(<span class="hljs-string">&quot;SECRET_KEY&quot;</span>))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app.run()<br></code></pre></div></td></tr></table></figure><p>我比较在意的是这个 <code>silent</code> 参数， 这个参数的含义是，当配置文件丢失时，或者环境变量没有设置时，设置 <code>silent</code> 参数为True，那么就等于没有配置这个文件。</p><p>那么可以写一个函数来检测这个配置文件是否存在，是否设置环境变量，当两个都没有时，返回 <code>True</code>，然后 <code>from_envvar</code> 方法将会不起作用，触发异常。</p><p>下面是一个简单的例子。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br><span class="hljs-keyword">import</span> os<br><br>app = Flask(__name__)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_set</span>():</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.environ.get(<span class="hljs-string">&quot;FLASK_CONFIG&quot;</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> os.path.exists(<span class="hljs-string">&quot;config.cfg&quot;</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>app.config.from_envvar(<span class="hljs-string">&quot;FLASK_CONFIG&quot;</span>, silent=is_set())<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span></span><br><span class="hljs-function">    <span class="hljs-title">return</span> &quot;<span class="hljs-title">DEBUG</span> %<span class="hljs-title">s</span> <span class="hljs-title">SECRET_KEY</span> %<span class="hljs-title">s</span>&quot; % (<span class="hljs-params">app.config.get(<span class="hljs-params"><span class="hljs-string">&quot;DEBUG&quot;</span></span>), app.config.get(<span class="hljs-params"><span class="hljs-string">&quot;SECRET_KEY&quot;</span></span>)</span>)</span><br><span class="hljs-function"></span><br>if __name__ == &quot;__main__&quot;:<br>    app.run()<br></code></pre></div></td></tr></table></figure><p>针对 <code>silent</code> 参数，写出一个方法来最终决定 <code>silent</code> 的值，这样防止了中间环境变量配置出错以及文件不存在等等情况。</p><h2 id="三、-从-python-文件中读取配置属性"><a href="#三、-从-python-文件中读取配置属性" class="headerlink" title="三、 从 python 文件中读取配置属性"></a>三、 从 <code>python</code> 文件中读取配置属性</h2><blockquote><p>  当创建一个 <code>Flask</code> 的实例对象之后，使用 <code>app.config.from_pyfile</code> 方法，传入一个配置文件字符串，从配置文件中读取属性并且写入，前面的 <code>from_envvar</code> 方法获取到配置文件后最终也会调用这个方法，并且，这个方法最终也会调用下一个方法 <code>from_object</code>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function">def <span class="hljs-title">from_pyfile</span><span class="hljs-params">(self, filename, silent=False)</span>:</span><br><span class="hljs-function">    filename </span>= os.path.join(self.root_path, filename)<br>        d = types.ModuleType(<span class="hljs-string">&quot;config&quot;</span>)<br>        d.__file__ = filename<br>    <span class="hljs-keyword">try</span>:<br>with open(filename, mode=<span class="hljs-string">&quot;rb&quot;</span>) as config_file:<br>exec(compile(config_file.read(), filename, <span class="hljs-string">&quot;exec&quot;</span>), d.__dict__)<br>    except IOError as e:<br><span class="hljs-keyword">if</span> silent <span class="hljs-keyword">and</span> e.errno in (errno.ENOENT, errno.EISDIR, errno.ENOTDIR):<br><span class="hljs-keyword">return</span> False<br>    e.strerror = <span class="hljs-string">&quot;Unable to load configuration file (%s)&quot;</span> % e.strerror<br>    raise<br>    self.from_object(d)<br>    <span class="hljs-keyword">return</span> True<br></code></pre></div></td></tr></table></figure><p>在项目的根目录下创建一个名为 <code>config.cfg</code> 简单配置文件。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">DEBUG=<span class="hljs-literal">True</span><br>SECRET_KEY=<span class="hljs-string">&quot;something&quot;</span><br></code></pre></div></td></tr></table></figure><p>先看 <code>from_pyfile</code> 文件前面的三段代码， 首先使用 <code>os</code>获取配置文件的绝对路径，然后用 <code>types.ModuleType</code> 方法动态创建了一个 <code>config</code> 模块，并且设置文件名为传进来的文件名的绝对路径文件名，此时这个 <code>config</code> 算是一个模块了，不是用普通的 <code>import</code> 方法导入的。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">filename = os.path.join(self.root_path, filename)<br>d = types.ModuleType(<span class="hljs-string">&quot;config&quot;</span>)<br>d.__file__ = filename<br></code></pre></div></td></tr></table></figure><p><code>types</code> 属于 <code>Python</code>的标准库，里面的几个常用的方法没怎么了解，有如下几个。</p><ul><li>  <code>FunctionType</code>：通过不使用 <code>def</code> 的方式动态创建一个函数。</li><li>  <code>MethodType</code>：将创建在类外的某个方法动态绑定到类的实例上。</li><li>  <code>ModuleType</code>：动态的创建一个临时的模块。</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> types<br><br><span class="hljs-comment"># 动态创建一个模块</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m = types.ModuleType(<span class="hljs-string">&quot;sample&quot;</span>, <span class="hljs-string">&quot;sample module.&quot;</span>)  <span class="hljs-comment"># 传入一个模块名，以及模块的文档字符串</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m<br>&lt;module <span class="hljs-string">&#x27;sample&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>m.__dict__<br>&#123;<span class="hljs-string">&#x27;__name__&#x27;</span>: <span class="hljs-string">&#x27;sample&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-string">&#x27;sample module.&#x27;</span>, <span class="hljs-string">&#x27;__package__&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;__loader__&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;__spec__&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>m <span class="hljs-keyword">in</span> sys.modules   <span class="hljs-comment"># 模块不包含在系统模块中</span><br><span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 动态添加类方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">pass</span><br><span class="hljs-meta">... </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>p = Person()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say</span>(<span class="hljs-params">self</span>):</span> print(<span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.say = types.MethodType(say, p)<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.say()<br>hello<br><br><span class="hljs-comment"># 动态创建一个函数</span><br>&gt;&gt; foo_code = <span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;def foo(): return &quot;bar&quot;&#x27;</span>, <span class="hljs-string">&quot;&lt;string&gt;&quot;</span>, <span class="hljs-string">&quot;exec&quot;</span>)<br>&gt;&gt; foo_func = types.FunctionType(foo_code.co_consts[<span class="hljs-number">0</span>], <span class="hljs-built_in">globals</span>(), <span class="hljs-string">&quot;foo&quot;</span>)<br>&gt;&gt; print(foo_func())<br>bar<br></code></pre></div></td></tr></table></figure><p>继续看 <code>from_pyfile</code> 方法剩下的代码，读取配置文件的配置属性，此时把属性放进动态创建的模块的字典里头，最后是调用另一个方法。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, mode=<span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> config_file:<br>exec(<span class="hljs-built_in">compile</span>(config_file.read(), filename, <span class="hljs-string">&quot;exec&quot;</span>), d.__dict__)<br><span class="hljs-keyword">except</span> IOError <span class="hljs-keyword">as</span> e:<br><span class="hljs-keyword">if</span> silent <span class="hljs-keyword">and</span> e.errno <span class="hljs-keyword">in</span> (errno.ENOENT, errno.EISDIR, errno.ENOTDIR):<br><span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    e.strerror = <span class="hljs-string">&quot;Unable to load configuration file (%s)&quot;</span> % e.strerror<br><span class="hljs-keyword">raise</span><br>self.from_object(d)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></div></td></tr></table></figure><h2 id="四、从-python对象中提取属性"><a href="#四、从-python对象中提取属性" class="headerlink" title="四、从  python对象中提取属性"></a>四、从  <code>python</code>对象中提取属性</h2><p>从 <code>python</code> 对象中提取配置相对简单，一般写一个配置类的 <code>python</code> 文件，里面定义一个基类，设定一些基本配置，然后使用类继承的方法为各种环境设置扩展配置类，一个简单的配置类如下。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    DEBUG = <span class="hljs-literal">False</span><br>    TESTING = <span class="hljs-literal">False</span><br>    DATABASE_URI = <span class="hljs-string">&#x27;sqlite://:memory:&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductionConfig</span>(<span class="hljs-params">Config</span>):</span><br>    DATABASE_URI = <span class="hljs-string">&#x27;mysql://user@localhost/foo&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DevelopmentConfig</span>(<span class="hljs-params">Config</span>):</span><br>    DEBUG = <span class="hljs-literal">True</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestingConfig</span>(<span class="hljs-params">Config</span>):</span><br>    TESTING = <span class="hljs-literal">True</span><br></code></pre></div></td></tr></table></figure><p>之后就是在 <code>from_object</code> 方法里传入一个类名，或者一个完整的模块字符串就可以配置好配置属性。如果传入的是一个配置类，那么 <code>   if isinstance(obj, string_types)</code> 直接为 <code>False</code>，然后这个传入的配置类的所有属性，如果包含大写的属性，将存入 <code>app.config</code> 的字典中。如果是字符串，那么会先把模块里面的类导入再提取属性。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_object</span>(<span class="hljs-params">self, obj</span>):</span><br>   <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(obj, string_types):<br>            obj = import_string(obj)<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> <span class="hljs-built_in">dir</span>(obj):<br>        <span class="hljs-keyword">if</span> key.isupper():<br>            self[key] = <span class="hljs-built_in">getattr</span>(obj, key)<br></code></pre></div></td></tr></table></figure><p><code>string_types</code> ，这个变量在  <code>flask</code> 包的  <code>_compat.py</code>  下，其实就是<code>string</code> 类型，所以简单对传进来的参数检查是不是个字符串，如果是字符串，则会调用 <code>import_string</code> 方法，如果不是字符串而是一个具体的类则直接执行 <code>for</code> 循环对类的属性遍历。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:  <span class="hljs-comment"># Python 2</span><br>    text_type = unicode<br>    string_types = (<span class="hljs-built_in">str</span>, unicode)<br>    integer_types = (<span class="hljs-built_in">int</span>, long)<br><span class="hljs-keyword">except</span> NameError:  <span class="hljs-comment"># Python 3</span><br>    text_type = <span class="hljs-built_in">str</span><br>    string_types = (<span class="hljs-built_in">str</span>,)<br>    integer_types = (<span class="hljs-built_in">int</span>,)<br></code></pre></div></td></tr></table></figure><p>然后是  <code>import_string</code> 方法，因为传进来的仅仅是个字符串，还没对模块进行导入，所以会用到 <code>werkzeug.utils</code> 包下的 <code>import_string</code> 方法对模块进行导入。</p><p>可以看到 <code>import_string</code>  的第一行代码会对字符串进行替换，那说明有两种写法，而恰恰函数文档也说明了。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">提供两种模块写法：例如</span><br><span class="hljs-string">xml.sax.saxutils.escape</span><br><span class="hljs-string">xml.sax.saxutils:escape</span><br><span class="hljs-string">无论是那种写法，最后都会变成下面这种写法</span><br><span class="hljs-string">xml.sax.saxutils.escape</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>import_name = <span class="hljs-built_in">str</span>(import_name).replace(<span class="hljs-string">&quot;:&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>接下来就是使用不寻常的导包方式，一般导包都是两种方式，<code>import package</code>或者是 <code>from package import module</code>，因为我们这里传进来的是字符串，所以不能用正常的导包方式，只能使用 <code>__import__</code> 这个内建方法，实际上 <code>import</code> 也是调用 <code>__import__</code>。假设配置类 <code>BaseConfig</code> 在 <code>Config</code>  包下的 <code>Settings.py</code> 模块下，那么可以写为 <code>Config.Settings:BaseConfig</code>，或者 <code>Config.Settings.BaseConfig</code> ，两者的可以。最终，如果导入为空时，那么会从 <code>sys.modules</code> 里面查询这个包。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">__import__</span>(import_name)<br><span class="hljs-keyword">except</span> ImportError:<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> import_name:<br>        <span class="hljs-keyword">raise</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> sys.modules[import_name]<br></code></pre></div></td></tr></table></figure><p>如果这个传入的配置类字符串为 <code>Config.Settings.BaseConfig</code>，那么先把模块名和对象名分开，再尝试使用 <code>__import__</code> 方法导入，此时已经把模块名和对象名分开了，分别把模块名和对象名传入 <code>__import__</code> 就可以正常导入。再使用 <code>getattr</code> 方法获取模块里面的对象，这个方法告一段落。最后就是把返回的对象遍历获取里面的配置属性添加到 <code>Config</code> 对象中。</p><p><code>__import_</code> 的四个参数：</p><ul><li>  <code>name (required)</code>: 被加载 <code>module</code> 的名称</li><li>  <code>globals (optional)</code> : 包含全局变量的字典，该选项很少使用，采用默认值 <code>global()</code></li><li>  <code>locals (optional)</code>:  包含局部变量的字典，内部标准实现未用到该变量，采用默认值 <code>local()</code></li><li>  <code>fromlist (Optional)</code> : 被导入的子模块名称</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">module_name, obj_name = import_name.rsplit(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-number">1</span>)<br>module = <span class="hljs-built_in">__import__</span>(module_name, <span class="hljs-built_in">globals</span>(), <span class="hljs-built_in">locals</span>(), [obj_name])<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(module, obj_name)<br><span class="hljs-keyword">except</span> AttributeError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-keyword">raise</span> ImportError(e)<br></code></pre></div></td></tr></table></figure><p>总的来说这个方法提供了两种导入配置的选择，一种是传入模块字符串，一种是直接传入配置类。便于导入的时候选择导入方式和可扩展性。</p><h2 id="五、从-json-文件中读取配置属性到映射为字典"><a href="#五、从-json-文件中读取配置属性到映射为字典" class="headerlink" title="五、从 json 文件中读取配置属性到映射为字典"></a>五、从 <code>json</code> 文件中读取配置属性到映射为字典</h2><p>这个方法最终也会调用 <code>Config</code> 类的最后一个方法，对于这个方法而言，只是简单的读取一下 <code>json</code> 文件，并且把 <code>json</code> 文件里面的数据转化为 <code>Python</code> 当中的字典类型。同时可以设置 <code>silent</code> 为 <code>True</code>，当文件读取失败的时候，方法直接失效，如果不设置为 <code>True</code> 的话，也可以，直接触发标准错误。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_json</span>(<span class="hljs-params">self, filename, silent=<span class="hljs-literal">False</span></span>):</span><br>    filename = os.path.join(self.root_path, filename)<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> json_file:<br>            obj = json.loads(json_file.read())<br><span class="hljs-keyword">except</span> IOError <span class="hljs-keyword">as</span> e:<br><span class="hljs-keyword">if</span> silent <span class="hljs-keyword">and</span> e.errno <span class="hljs-keyword">in</span> (errno.ENOENT, errno.EISDIR):<br><span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>e.strerror = <span class="hljs-string">&quot;Unable to load configuration file (%s)&quot;</span> % e.strerror<br><span class="hljs-keyword">raise</span><br><span class="hljs-keyword">return</span> self.from_mapping(obj)<br></code></pre></div></td></tr></table></figure><p>在项目的根目录下创建一个名为 <code>config.json</code> 的配置文件。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">&#123;<br>    <span class="hljs-string">&quot;DEBUG&quot;</span>: <span class="hljs-string">&quot;True&quot;</span>,<br>    <span class="hljs-string">&quot;SECRET_KEY&quot;</span>: <span class="hljs-string">&quot;something&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>示例代码，当程序启动时，打开 <code>http://127.0.0.1:5000/</code> 就可以看到 <code>DEBUG</code> 和 <code>SECRET_KEY </code> 的值。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br><br>app = Flask(__name__)<br><br>app.config.from_json(<span class="hljs-string">&quot;config.json&quot;</span>)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DEBUG %s SECRET_KEY %s&quot;</span> % (app.config.get(<span class="hljs-string">&quot;DEBUG&quot;</span>), app.config.get(<span class="hljs-string">&quot;SECRET_KEY&quot;</span>))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app.run()<br>    print(app.config.items())<br></code></pre></div></td></tr></table></figure><h2 id="六、从-python-键值对-dict-中配置属性"><a href="#六、从-python-键值对-dict-中配置属性" class="headerlink" title="六、从 python 键值对 ( dict ) 中配置属性"></a>六、从 <code>python</code> 键值对 <code>( dict )</code> 中配置属性</h2><p>设置一个简单的字典对象，待会传入 <code>from_mappings</code> 方法。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">configs = &#123;<br>    <span class="hljs-string">&quot;DEBUG&quot;</span>: <span class="hljs-literal">True</span>,<br>    <span class="hljs-string">&quot;SECRET_KEY&quot;</span>: <span class="hljs-string">&quot;Something&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>最后一个方法，针对传进来的键值对，也就是字典，这里对应第三个参数 <code>**kwargs</code>，使用 <code>kwargs.items()</code> 提取出所有的键值对( 列表格式 ) 存放进 <code>mappings</code> 列表里，然后再通过二层循环提取出每个配置的键和值，存放进 <code>Config</code> 类的里面。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_mapping</span>(<span class="hljs-params">self, *mapping, **kwargs</span>):</span><br>    <br>        mappings = []<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(mapping) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(mapping[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;items&quot;</span>):<br>                mappings.append(mapping[<span class="hljs-number">0</span>].items())<br>            <span class="hljs-keyword">else</span>:<br>                mappings.append(mapping[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(mapping) &gt; <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">raise</span> TypeError(<br>                <span class="hljs-string">&quot;expected at most 1 positional argument, got %d&quot;</span> % <span class="hljs-built_in">len</span>(mapping)<br>            )<br>        mappings.append(kwargs.items())<br>        <span class="hljs-keyword">for</span> mapping <span class="hljs-keyword">in</span> mappings:<br>            <span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> mapping:<br>                <span class="hljs-keyword">if</span> key.isupper():<br>                    self[key] = value<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></div></td></tr></table></figure><p>例子示范，当启动程序时，在浏览器进入 <code>http://127.0.0.1:5000/</code> 就能看到 <code>DEBUG</code> 和 <code>SECRET_KEY</code> 的值。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br><br>app = Flask(__name__)<br><br>configs = &#123;<br>    <span class="hljs-string">&quot;DEBUG&quot;</span>: <span class="hljs-literal">True</span>,<br>    <span class="hljs-string">&quot;SECRET_KEY&quot;</span>: <span class="hljs-string">&quot;Something&quot;</span><br>&#125;<br><br>app.config.from_mappings(configs)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DEBUG %s SECRET_KEY %s&quot;</span> % (app.config.get(<span class="hljs-string">&quot;DEBUG&quot;</span>), app.config.get(<span class="hljs-string">&quot;SECRET_KEY&quot;</span>))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app.run()<br>    print(app.config.items())<br></code></pre></div></td></tr></table></figure><p>然后这个方法还提供另一种细化的使用，上面只是传入了第三个参数，第二个参数还没使用，显然这个函数是会使用到第二参数，那么这个参数格式有几种写法：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">mapping = (<br>    &#123;<br>        <span class="hljs-string">&quot;DEBUG&quot;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&quot;SECRET_KEY&quot;</span>: <span class="hljs-string">&quot;Something&quot;</span><br>    &#125;<br>)<br><span class="hljs-comment"># 直接执行 mappings.append(mapping[0])</span><br><br>mapping = (<br>    (<span class="hljs-string">&#x27;DEBUG&#x27;</span>, <span class="hljs-literal">True</span>),<br>    (<span class="hljs-string">&#x27;TESTING&#x27;</span>, <span class="hljs-literal">False</span>)<br>)<br><span class="hljs-comment"># 传入元祖，直接执行 mappings.append(mapping[0])</span><br></code></pre></div></td></tr></table></figure><p>此时就不需要传入第三个参数，也就是说这个方法提供两种参数传入方式，也方便扩展，如果单纯使用键值对，那么前面的代码将不会被执行，如果使用 <code>tuple</code> ，也会对这个参数进行操作，提取里面的属性值。</p><h2 id="七、自定义读取-yaml-properties配置文件"><a href="#七、自定义读取-yaml-properties配置文件" class="headerlink" title="七、自定义读取 yaml/properties配置文件"></a>七、自定义读取 yaml/properties配置文件</h2><blockquote><p>  上面提到可以用 <code>types.MethodType</code> 来创建动态方法，这里就可以利用这个来为 <code>config</code> 扩展读取更多类型的配置文件。</p></blockquote><p>示例如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> types<br><br><span class="hljs-comment"># 创建一个 Person 类，此时类里还没有任何方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say</span>(<span class="hljs-params">self, name</span>):</span><br>    self.name = name<br>    print(<span class="hljs-string">&quot;hello&quot;</span>, name)<br>    <br>p = Person()<br><br><span class="hljs-comment"># 强行把方法赋值到实例对象上</span><br>p.say = say<br><br>p.say(name=<span class="hljs-string">&quot;nick&quot;</span>) <br><span class="hljs-comment"># 报错</span><br><span class="hljs-comment"># say() missing 1 required positional argument: &#x27;self&#x27;</span><br><br><span class="hljs-comment"># 把 say 方法绑定到 Person 类的实例上</span><br>p.say = types.MethodType(say, p)<br><br>p.say(name=<span class="hljs-string">&quot;nick&quot;</span>)<br><br><span class="hljs-comment"># result: hello nick</span><br></code></pre></div></td></tr></table></figure><p>创建一个名为 <code>config.yaml</code> 的配置文件，写入两个简单的配置项。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">DEBUG:</span> <span class="hljs-literal">True</span><br><span class="hljs-attr">SECRET_KEY:</span> <span class="hljs-string">something</span><br></code></pre></div></td></tr></table></figure><p>读取 <code>yaml</code> 文件，编写读取 <code>yaml</code> 文件方法，利用了 <code>pyyaml</code> 库，使用  <code>yaml</code> 读取出来的数据是字典格式，然后传递给  <code>Config</code> 对象的        <code>from_mapping</code> 方法，然后利用 <code>types.MethodType</code> 方法为 <code>Config</code> 类动态添加方法，绑定在 <code>config</code> 对象上。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br><span class="hljs-keyword">import</span> types<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> yaml<br><br><br>app = Flask(__name__)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_yaml</span>(<span class="hljs-params">self, filename, silent=<span class="hljs-literal">False</span></span>):</span><br>    filename = os.path.join(self.root_path, filename)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> yaml_file:<br>            obj = yaml.load(yaml_file.read(), Loader=yaml.FullLoader)<br>    <span class="hljs-keyword">except</span> IOError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">if</span> silent:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> self.from_mapping(obj)<br><br><span class="hljs-comment"># MethodType 方法第一个参数是需要动态添加的方法名，第二个参数是类的实例对象。</span><br>app.config.from_yaml = types.MethodType(from_yaml, app.config)<br>app.config.from_yaml(<span class="hljs-string">&quot;config.yaml&quot;</span>)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DEBUG %s SECRET_KEY %s&quot;</span> % (app.config.get(<span class="hljs-string">&quot;DEBUG&quot;</span>), app.config.get(<span class="hljs-string">&quot;SECRET_KEY&quot;</span>))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app.run()<br>    print(app.config.items())<br></code></pre></div></td></tr></table></figure><p>创建一个名为 <code>config.properties</code> 的简单配置文件，写入以下简单配置项。</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">DEBUG</span>=<span class="hljs-string">True</span><br><span class="hljs-attr">SECRET_KEY</span>=<span class="hljs-string">something</span><br></code></pre></div></td></tr></table></figure><p>创建一个读取 <code>from_properties</code> 方法， 这个方法遍历  <code>properties</code> 文件的每一行，把  <code>=</code>  两边的属性名和属性值放进 <code>obj</code> 中，最终会调用现有的 <code>from_mapping</code> 方法，最后还是要利用 <code>types.MethodType</code> 方法为 <code>Config</code> 类动态添加方法，绑定在 <code>config</code> 对象上，这样这个方法才会起作用。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">app = Flask(__name__)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_properties</span>(<span class="hljs-params">self, filename, silent=<span class="hljs-literal">False</span>, encode=<span class="hljs-literal">None</span></span>):</span><br>    filename = os.path.join(self.root_path, filename)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> properties_file:<br>            obj = &#123;&#125;<br>            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> properties_file:<br>                <span class="hljs-keyword">if</span> line.find(<span class="hljs-string">&#x27;=&#x27;</span>) &gt; <span class="hljs-number">0</span>:<br>                    s = line.replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).split(<span class="hljs-string">&quot;=&quot;</span>)<br>                    obj[s[<span class="hljs-number">0</span>]] = s[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">except</span> IOError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">if</span> silent:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> self.from_mapping(obj)<br><br>app.config.from_properties = types.MethodType(from_properties, app.config)<br><br>app.config.from_properties(<span class="hljs-string">&quot;config.properties&quot;</span>)<br><br><br></code></pre></div></td></tr></table></figure><p>当然，这两个方法可能也有不完善的地方，例如，<code>yaml</code> 文件可能是多层级的，这里只考虑到一层级，什么时候下才会出现多层级的配置项，例如，可以在一个 <code>yaml</code> 文件里面设置多个环境配置，开发环境配置，生产环境配置，部署环境配置等。</p><ul><li>  [ ] <code>yaml</code> 方法修改。</li><li>  [ ] 实例代码上传至 <code>github</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux与Android剪切板同步方案</title>
    <link href="/2020/0516/12368.html"/>
    <url>/2020/0516/12368.html</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-与-Android-剪切板同步方案"><a href="#Linux-与-Android-剪切板同步方案" class="headerlink" title="Linux 与 Android 剪切板同步方案"></a><code>Linux</code> 与 <code>Android</code> 剪切板同步方案</h1><p>在 <code>Linux</code> 传输文件，图片，或是发送文字，都不如 <code>Windows</code> 那样方便，在 <code>Windows</code>  可以通过 <code>QQ</code> 里面发送文件，图片，或是文字等等。虽然说在<code>Linux</code>上可以通过其他方式来解决传文件的文件，例如：</p><span id="more"></span><ul><li><p>  <code>telegram</code></p></li><li><p>  微信网页版( 在2017年9月份开始，腾讯已经 开始限制 新注册的微信号禁止登录网页版微信，老的微信号则不受影响 ，并且网页版发送的文件大小不能超过 <code>90MB</code></p></li><li><p>  <code>python -m http.server 80</code>，但是不能复制文本，而且有些文件需要另存为下载。</p></li><li><p>  以及其他方法。。。</p></li></ul><p>现在找到 一种办法，电脑上使用 <code>GSConnect</code>，而安卓软件选择使用 <code>KDE Connect</code>。</p><p><code>GSConnect</code> 官方介绍：</p><blockquote><p>  <code>GSConnect</code> 是针对 <code>GNOME Shell</code> 的 <code>KDE Connect</code> 的完整实现，集成了 <code>Nautilus</code> 、<code>Chrome</code> 和 <code>Firefox</code>。</p><p>  将你的 PC 和 Android 设备与安装的 KDE Connect 应用配对: 传输文件，发送和接收短信文本，同步剪贴板和通知，发送鼠标和键盘输入，远程控制媒体播放器，定位你的设备，监视电池电量，在你的 PC 上启动命令，等等。</p></blockquote><p><code>GSConnect</code> 官方 <code>WIKI</code>：<a href="https://github.com/andyholmes/gnome-shell-extension-gsconnect/wiki/Installation#install-from-git">https://github.com/andyholmes/gnome-shell-extension-gsconnect/wiki/Installation#install-from-git</a></p><p><code>KDE Connect</code>可以在 <code>Google Play</code> 下载。</p><h2 id="1-安装方式"><a href="#1-安装方式" class="headerlink" title="1. 安装方式"></a>1. 安装方式</h2><p><code>GSConnect</code> 提供了两种安装方式，一种是通过从官方仓库的 <code>release</code> 页面下载最后一个版本的压缩包安装，另一种方式就是克隆官方仓库进行编译。</p><p>第一种方式的方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">mkdir -p ~/.local/share/gnome-shell/extensions<br>rm -rf ~/.local/share/gnome-shell/extensions/gsconnect@andyholmes.github.io<br>unzip -o gsconnect@andyholmes.github.io.zip -d ~/.local/share/gnome-shell/extensions/gsconnect@andyholmes.github.io<br></code></pre></div></td></tr></table></figure><p>第二种方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git clone https://github.com/andyholmes/gnome-shell-extension-gsconnect.git<br>cd gnome-shell-extension-gsconnect/<br>meson _build .<br>ninja -C _build install-zip<br></code></pre></div></td></tr></table></figure><p>选择第一种方式更方便，不需要编译，我选择的是第一种方式。</p><p>使用第二种安装方式的时候，编译出现了点问题，缺少两个构建工具：meson， ninja。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo aptitude install meson<br></code></pre></div></td></tr></table></figure><p>同时会安装 meson和ninja。</p><p>开始，构建，报错。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">The Meson build system<br>Version: 0.45.1<br>Source dir: /home/aim/SoftWare/gnome-shell-extension-gsconnect<br>Build dir: /home/aim/SoftWare/gnome-shell-extension-gsconnect/_build<br>Build type: native build<br><br>meson.build:1:0: ERROR: Meson version is 0.45.1 but project requires &gt;= 0.49.0.<br><br>A full log can be found at /home/aim/SoftWare/gnome-shell-extension-gsconnect/_build/meson-logs/meson-log.txt<br></code></pre></div></td></tr></table></figure><p>原来是meson版本低于依赖的版本。安装高版本的meson</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">pip install meson==0.49.0<br></code></pre></div></td></tr></table></figure><h2 id="2-开始使用"><a href="#2-开始使用" class="headerlink" title="2. 开始使用"></a>2. 开始使用</h2><p>手机要和电脑处在同一个局域网，不然搜索不到。</p><p>手机打开 <code>Kde Connect</code>，点击 <code>⊕ Pair new device</code> 扫描周围设备进行配对，出现电脑名字的时候点击进行配对，电脑上点击<code>accept</code> 即可配对成功。</p><p>同时，为了方便的管理电脑上的剪切板剪切的文件，安装一个剪切板管理软件。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo aptitude install copyq<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
